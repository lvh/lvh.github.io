<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lvh (Posts about clojure)</title><link>https://www.lvh.io/</link><description></description><atom:link href="https://www.lvh.io/tags/clojure.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 24 Nov 2019 19:24:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Clojure and native-image on JDK 11-flavored GraalVM (19.3.0+)</title><link>https://www.lvh.io/posts/clojure-and-native-image-on-jdk-11-flavored-graalvm-1930%2B/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;My takeaways from &lt;a href="https://www.graalvm.org/docs/release-notes/19_3/"&gt;the GraalVM 19.3.0 release notes&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDK code inlining support&lt;/li&gt;
&lt;li&gt;Optional JDK11 support&lt;/li&gt;
&lt;li&gt;Better Windows support&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These may not seem like much, but JDK code inlining fixes my one major niggle
with native-image: it was too hard to get top-notch single-binary TLS, and
now it just works.&lt;/p&gt;
&lt;p&gt;(There are lots of other great things that happened in this release! They're
just not in parts of Graal I use.)&lt;/p&gt;
&lt;h2&gt;Updating to JDK 11&lt;/h2&gt;
&lt;p&gt;Updating to JDK 11 is optional, but you might as well get it over with now.&lt;/p&gt;
&lt;h3&gt;A brief summary of Jigsaw (JDK9+) breakage&lt;/h3&gt;
&lt;p&gt;There are two things that bit Clojure-using early adopters of JDK 9, both
consequences of &lt;a href="https://openjdk.java.net/projects/jigsaw/"&gt;Project Jigsaw&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The module system hiding previously-available classes&lt;/li&gt;
&lt;li&gt;Changes to the way classloaders work&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These two changes broke Clojure and a whole host of common libraries (mostly
because of the now-unavailable classes) and the two common build tools
(leiningen and boot, mostly because of the bootclassloader). These were quickly
resolved and only affect you now if you care about supporting a long range of
Clojure versions or a long range of JDKs. Since this blog post is about
native-image, your output is a standalone binary and you get to pick the JDK
version. However, you still need to know a bit about this background in order to
understand some of the workarounds necessary for supporting GraalVM native-image
targeting JDK11 and above. This is happening now because Graal was previously
targeting JDK8, avoiding all of these issues.&lt;/p&gt;
&lt;p&gt;The two classes that tend to come up that were often used but hidden in modules
are &lt;code&gt;java.sql.Timestamp&lt;/code&gt; and &lt;code&gt;javax.xml.bind.DatatypeConverter&lt;/code&gt;. Despite their
package names, they don't have anything to do with SQL or XML. Clojure used them
because &lt;code&gt;Timestamp&lt;/code&gt; was the good instant type (&lt;code&gt;java.util.Date&lt;/code&gt; being famously
bad), and &lt;code&gt;DatatypeConverter&lt;/code&gt; was the good Base64 implementation available
everywhere.&lt;/p&gt;
&lt;h3&gt;Example: DatatypeConverter in clj-http-lite&lt;/h3&gt;
&lt;p&gt;Outside of Clojure, clj-http and clj-http-lite used &lt;code&gt;DatatypeConverter&lt;/code&gt; as well
(also for base64). clj-http-lite is very popular in native-image Clojure
projects. Like other libraries, they were quickly patched to support JDK9. The
patch still attempted to import &lt;code&gt;DatatypeConverter&lt;/code&gt; (see &lt;a href="https://github.com/martinklepsch/clj-http-lite/commit/3f41fc53a1b692549c88a8602e753cfb887330ae"&gt;the actual patch in
clj-http-lite&lt;/a&gt;), because the Base64 implementation
replacing it isn't available on every JDK those libraries wanted to support.
Normally, this is fine: the import fails and the alternative library gets used.
However, the static analysis step in GraalVM sees the trial import and
complains:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;graal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pointsto&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;constraints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UnresolvedElementException&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Discovered&lt;/span&gt; &lt;span class="n"&gt;unresolved&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;during&lt;/span&gt; &lt;span class="n"&gt;parsing&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;javax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;xml&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;DatatypeConverter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;To&lt;/span&gt; &lt;span class="n"&gt;diagnose&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;issue&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;allow&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;incomplete&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;classpath&lt;/span&gt; &lt;span class="n"&gt;option&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;reported&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;accessed&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The classic workaround was to add the module back with &lt;code&gt;--add-modules
java.xml.bind&lt;/code&gt;. Since it's just a trial import (see patch), you can instead use
the workaround suggested in the error message (&lt;code&gt;--allow-incomplete-classpath&lt;/code&gt;)
and it'll work fine. The downside is this moves &lt;em&gt;all&lt;/em&gt; errors to runtime. There's
a &lt;a href="https://github.com/oracle/graal/issues/1664"&gt;Graal ticket&lt;/a&gt; for a more precise command line
argument limiting the suppressed error to that class. I'm confident there's
already a way to express this in Graal command line arguments, but I haven't
tried to figure out the right incantation yet.&lt;/p&gt;
&lt;h3&gt;Single binary TLS!&lt;/h3&gt;
&lt;p&gt;Once you fix the above issue with clj-http-lite, as long as you enable the TLS
subsystem (&lt;code&gt;--enable-https&lt;/code&gt;), you'll just get single-binary HTTPS with
libsunec.so under the hood, meaning I can finally close
&lt;a href="https://github.com/oracle/graal/issues/1336"&gt;#1336&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;locking&lt;/code&gt; errors appear to be gone... sometimes?&lt;/h3&gt;
&lt;p&gt;Clojure 1.10+ introduces a dependency on clojure.spec. That library is unusual
because it uses the &lt;code&gt;locking&lt;/code&gt; macro. Ordinarily, the &lt;code&gt;locking&lt;/code&gt; macro is pretty
rare because Clojure has different, higher-level concurrency primitives.&lt;/p&gt;
&lt;p&gt;Bytecode verifiers that are more aggressive than those in the JDK would balk at
the resulting bytecode. Historically this was the Android toolchain, but the
issue resurfaced with Graal. This got documented in &lt;a href="https://clojure.atlassian.net/browse/CLJ-1472"&gt;CLJ-1472&lt;/a&gt;.
This issue had a whole myriad of workarounds that mostly involved replacing the
&lt;code&gt;locking&lt;/code&gt; implementation and then hooking clj loads with dynapath. The most
common workaround was to just downgrade Clojure to 1.9.0.&lt;/p&gt;
&lt;p&gt;With Graal 19.3.0, the error appears to have simply disappeared. I don't know
which Graal change precipitated this, but I'll happily take being able to use
the current release of Clojure without hacks. (FWIW: this doesn't appear to be
the case for everyone, so likely some combination of events just made it harder
to trigger the problem.)&lt;/p&gt;
&lt;h2&gt;Example project&lt;/h2&gt;
&lt;p&gt;I updated https://github.com/lvh/cljurl-graalvm-demo if you want to try any of
this at home. If you're on Linux and want to debug the TLS issues, I wrote
https://github.com/lvh/nscap specifically for this purpose. It leverages Linux
namespaces to elegantly capture network traffic for a single process. You can
then throw the resulting PCAP into e.g. wireguard.&lt;/p&gt;
&lt;h2&gt;What I'd still love to see in native-image&lt;/h2&gt;
&lt;p&gt;The compiler is slow. It's in the range of rustc speed: typically faster than
C++, certainly slower than Go. It eats a lot of RAM. It's fine because I don't
iterate on the binary version. I develop Clojure apps targeting native-image as
if they're normal Clojure apps and then eventually run some end-to-end tests on
the binary. But you knocked out my #1 feature so now I have a new one 😊&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><guid>https://www.lvh.io/posts/clojure-and-native-image-on-jdk-11-flavored-graalvm-1930%2B/</guid><pubDate>Sun, 24 Nov 2019 16:50:15 GMT</pubDate></item><item><title>Smaller Clojure Docker builds with multi-stage builds</title><link>https://www.lvh.io/posts/smaller-clojure-docker-builds-with-multi-stage-builds/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;A common pattern in Docker is to use a separate build environment from the
runtime environment. Many platforms have different requirements when you're
generating a runnable artifact than when you're running it.&lt;/p&gt;
&lt;p&gt;In languages like Go, Rust or C, where the most common implementations produce
native binaries, the resulting artifact may require nothing from the environment
at all, or perhaps as little as a C standard library. Even in languages like
Python that don't typically have a build step, you might indirectly use code
that still requires compilation. Common examples include OpenSSL with
pyca/cryptography or NETLIB and other numerical libraries with numpy/scipy.&lt;/p&gt;
&lt;p&gt;In Clojure, you can easily build "uberjars" with both lein and boot. These are
jars (the standard JVM deployable artifact) that come with all dependencies
prepackaged, requiring nothing beyond what's in the Java standard library
(rt.jar). While this still requires a JRE to run, that is still much smaller
than the full development environment.&lt;/p&gt;
&lt;p&gt;There are a few advantages to separating environments. It all boils down to them
not having anything in them they don't need. That has clear performance
advantages, although Docker has historically mitigated this problem with layered
pulls. It can have security benefits as well: you can't have bugs in software
you don't ship. Even software that isn't directly used in the build process can
be affected: some build environments will contain plenty of software that is
never used that would normally carry over into your production environments.&lt;/p&gt;
&lt;p&gt;Historically, most users of Docker haven't bothered. Even if there are
advantages, they aren't worth the hassle of having separate Docker environments
and ferrying data between them. While different ways of effectively sharing data
between containers have been available for years, people who wanted a shared
build step have mostly had to write their own tooling. For example,
my &lt;a href="https://github.com/lvh/icecap/blob/master/utils/build-libsodium-package.sh"&gt;icecap&lt;/a&gt; project has a batch file with an embedded Dockerfile that builds
libsodium debs.&lt;/p&gt;
&lt;p&gt;The upcoming release of Docker will add support for a new feature called
multi-stage builds, where this pattern is much simpler. Dockerfiles themselves
know about your precursor environments now, and future containers have full
access to previous containers for copying build artifacts around. This
requires Docker 17.05 or newer.&lt;/p&gt;
&lt;p&gt;Here's an example Dockerfile that builds an uberjar from a standard lein-based
app, and puts it in a new JRE image:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;FROM clojure AS build-env
WORKDIR /usr/src/myapp
COPY project.clj /usr/src/myapp/
RUN lein deps
COPY . /usr/src/myapp
RUN mv "$(lein uberjar | sed -n 's/^Created \(.*standalone\.jar\)/\1/p')" myapp-standalone.jar

FROM openjdk:8-jre-alpine
WORKDIR /myapp
COPY --from=build-env /usr/src/myapp/myapp-standalone.jar /myapp/myapp.jar
ENTRYPOINT ["java", "-jar", "/myapp/myapp.jar"]
&lt;/pre&gt;


&lt;p&gt;This captures the uberjar name from the &lt;code&gt;lein uberjar&lt;/code&gt; output. If your uberjar
name doesn't end in &lt;code&gt;.standalone.jar&lt;/code&gt;, that won't work. You can change the name
of the uberjar with the &lt;code&gt;:uberjar-name&lt;/code&gt; setting in &lt;code&gt;project.clj&lt;/code&gt;. If you set it
to &lt;code&gt;myapp-standalone.jar&lt;/code&gt;, you don't need the gnarly &lt;code&gt;sed&lt;/code&gt; expression anymore at
all, and can just call &lt;code&gt;lein uberjar&lt;/code&gt;. (Thanks to Łukasz Korecki for the
suggestion!)&lt;/p&gt;
&lt;p&gt;The full clojure base image is a whopping 629MB (according to &lt;code&gt;docker images&lt;/code&gt;),
whereas &lt;code&gt;openjdk:8-jre-alpine&lt;/code&gt; clocks in at 81.4MB. That's a little bit of an
unfair comparison: &lt;code&gt;clojure&lt;/code&gt; also has an alpine-based image. However, this still
illustrates the savings compared to the most commonly used Docker image.&lt;/p&gt;
&lt;p&gt;There are still good reasons for not using multi-stage builds. In the icecap
example above, the entire point is to use Docker as a build system to produce
a deb artifact &lt;em&gt;outside of Docker&lt;/em&gt;. However, that's a pretty exotic use case:
for most people this will hopefully make smaller Docker images an easy
reality.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edited:&lt;/em&gt; The original blog post said that the Docker version to support this
feature was in beta at time of writing. That was/is correct, but it's since
been released, so I updated the post.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edited:&lt;/em&gt;* Łukasz Korecki pointed out that &lt;code&gt;project.clj&lt;/code&gt; has an &lt;code&gt;:uberjar-name&lt;/code&gt;
parameter which can be used to avoid the gnarly &lt;code&gt;sed&lt;/code&gt; expression. Thanks Łukasz!&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><category>docker</category><guid>https://www.lvh.io/posts/smaller-clojure-docker-builds-with-multi-stage-builds/</guid><pubDate>Fri, 16 Jun 2017 17:12:46 GMT</pubDate></item><item><title>What the heck is a clojure.lang.IFn$LO?</title><link>https://www.lvh.io/posts/what-the-heck-is-a-clojurelangifnlo/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;It's no secret that I love Clojure. Like any tool though, it isn't
perfect. Today, I was trying to write unit tests that use
&lt;code class="docutils literal"&gt;clojure.core.async/timeout&lt;/code&gt;, so I wrote a test double analogous to
Twisted's &lt;code class="docutils literal"&gt;Clock&lt;/code&gt;. As I tried to &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;with-redefs&lt;/span&gt;&lt;/code&gt; it in, I got the
most inscrutable error message out: &lt;code class="docutils literal"&gt;java.lang.ClassCastException:
icecap.handlers.delay_test$fake_timeout$timeout__22934 cannot be cast
to clojure.lang.IFn$LO&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wha? I know &lt;code class="docutils literal"&gt;clojure.lang.IFn&lt;/code&gt;, Clojure's function type, but what
the heck is a &lt;code class="docutils literal"&gt;clojure.lang.IFn$LO&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Searching for the term didn't give any particularly useful results. It
was clear this happened when I was redeffing the original &lt;code class="docutils literal"&gt;timeout&lt;/code&gt;,
so I looked at its documentation:&lt;/p&gt;
&lt;pre class="literal-block"&gt;clojure.core.async/timeout
([msecs])
Returns a channel that will close after msecs&lt;/pre&gt;
&lt;p&gt;Doesn't look too special to me. What's the type of that thing, anyway?
Let's find out:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type timeout))
#{clojure.lang.IFn$LO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;Aha! So that is actually part of &lt;code class="docutils literal"&gt;timeout&lt;/code&gt;, not something else wonky
going on. What does the source say? It's a pretty lame shim:&lt;/p&gt;
&lt;pre class="literal-block"&gt;(defn timeout
"Returns a channel that will close after msecs"
[^long msecs]
(timers/timeout msecs))&lt;/pre&gt;
&lt;p&gt;I mean, nothing interesting there, just a type hint.&lt;/p&gt;
&lt;p&gt;Oh. Wait. That's not just a type hint. &lt;code class="docutils literal"&gt;long&lt;/code&gt; is a primitive.
Testing:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type (fn [^long x] x)))
#{clojure.lang.IFn$LO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;Aha! Due to a JVM quirk, functions with a primitive type hint are
special. That works for doubles, too:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type (fn [^double x] x)))
#{clojure.lang.IFn$DO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;And multiple arguments:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type (fn [^double x ^double y] x)))
#{clojure.lang.IFn$DDO clojure.lang.AFunction}
&amp;gt; (parents (type (fn [^double x ^long y] x)))
#{clojure.lang.IFn$DLO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;Adding a simple type hint to the function fixed it. Success!&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><guid>https://www.lvh.io/posts/what-the-heck-is-a-clojurelangifnlo/</guid><pubDate>Thu, 02 Oct 2014 13:15:17 GMT</pubDate></item></channel></rss>