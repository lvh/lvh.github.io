<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lvh (Posts about clojure)</title><link>https://www.lvh.io/</link><description></description><atom:link href="https://www.lvh.io/tags/clojure.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sat, 30 Nov 2019 18:40:56 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Clojure and native-image on JDK 11-flavored GraalVM (19.3.0+)</title><link>https://www.lvh.io/posts/clojure-and-native-image-on-jdk-11-flavored-graalvm-1930%2B/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;My takeaways from &lt;a href="https://www.graalvm.org/docs/release-notes/19_3/"&gt;the GraalVM 19.3.0 release notes&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDK code inlining support&lt;/li&gt;
&lt;li&gt;Optional JDK11 support&lt;/li&gt;
&lt;li&gt;Better Windows support&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These may not seem like much, but JDK code inlining fixes my one major niggle
with native-image: it was too hard to get top-notch single-binary TLS, and
now it just works.&lt;/p&gt;
&lt;p&gt;(There are lots of other great things that happened in this release! They're
just not in parts of Graal I use.)&lt;/p&gt;
&lt;h2&gt;Updating to JDK 11&lt;/h2&gt;
&lt;p&gt;Updating to JDK 11 is optional, but you might as well get it over with now.&lt;/p&gt;
&lt;h3&gt;A brief summary of Jigsaw (JDK9+) breakage&lt;/h3&gt;
&lt;p&gt;There are two things that bit Clojure-using early adopters of JDK 9, both
consequences of &lt;a href="https://openjdk.java.net/projects/jigsaw/"&gt;Project Jigsaw&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The module system hiding previously-available classes&lt;/li&gt;
&lt;li&gt;Changes to the way classloaders work&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These two changes broke Clojure and a whole host of common libraries (mostly
because of the now-unavailable classes) and the two common build tools
(leiningen and boot, mostly because of the bootclassloader). These were quickly
resolved and only affect you now if you care about supporting a long range of
Clojure versions or a long range of JDKs. Since this blog post is about
native-image, your output is a standalone binary and you get to pick the JDK
version. However, you still need to know a bit about this background in order to
understand some of the workarounds necessary for supporting GraalVM native-image
targeting JDK11 and above. This is happening now because Graal was previously
targeting JDK8, avoiding all of these issues.&lt;/p&gt;
&lt;p&gt;The two classes that tend to come up that were often used but hidden in modules
are &lt;code&gt;java.sql.Timestamp&lt;/code&gt; and &lt;code&gt;javax.xml.bind.DatatypeConverter&lt;/code&gt;. Despite their
package names, they don't have anything to do with SQL or XML. Clojure used them
because &lt;code&gt;Timestamp&lt;/code&gt; was the good instant type (&lt;code&gt;java.util.Date&lt;/code&gt; being famously
bad), and &lt;code&gt;DatatypeConverter&lt;/code&gt; was the good Base64 implementation available
everywhere.&lt;/p&gt;
&lt;h3&gt;Example: DatatypeConverter in clj-http-lite&lt;/h3&gt;
&lt;p&gt;Outside of Clojure, clj-http and clj-http-lite used &lt;code&gt;DatatypeConverter&lt;/code&gt; as well
(also for base64). clj-http-lite is very popular in native-image Clojure
projects. Like other libraries, they were quickly patched to support JDK9. The
patch still attempted to import &lt;code&gt;DatatypeConverter&lt;/code&gt; (see &lt;a href="https://github.com/martinklepsch/clj-http-lite/commit/3f41fc53a1b692549c88a8602e753cfb887330ae"&gt;the actual patch in
clj-http-lite&lt;/a&gt;), because the Base64 implementation
replacing it isn't available on every JDK those libraries wanted to support.
Normally, this is fine: the import fails and the alternative library gets used.
However, the static analysis step in GraalVM sees the trial import and
complains:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;graal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pointsto&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;constraints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UnresolvedElementException&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Discovered&lt;/span&gt; &lt;span class="n"&gt;unresolved&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;during&lt;/span&gt; &lt;span class="n"&gt;parsing&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;javax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;xml&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;DatatypeConverter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;To&lt;/span&gt; &lt;span class="n"&gt;diagnose&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;issue&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;allow&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;incomplete&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;classpath&lt;/span&gt; &lt;span class="n"&gt;option&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;reported&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;accessed&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The classic workaround was to add the module back with &lt;code&gt;--add-modules
java.xml.bind&lt;/code&gt;. Since it's just a trial import (see patch), you can instead use
the workaround suggested in the error message (&lt;code&gt;--allow-incomplete-classpath&lt;/code&gt;)
and it'll work fine. The downside is this moves &lt;em&gt;all&lt;/em&gt; errors to runtime. There's
a &lt;a href="https://github.com/oracle/graal/issues/1664"&gt;Graal ticket&lt;/a&gt; for a more precise command line
argument limiting the suppressed error to that class. I'm confident there's
already a way to express this in Graal command line arguments, but I haven't
tried to figure out the right incantation yet.&lt;/p&gt;
&lt;h3&gt;Single binary TLS!&lt;/h3&gt;
&lt;p&gt;Once you fix the above issue with clj-http-lite, as long as you enable the TLS
subsystem (&lt;code&gt;--enable-https&lt;/code&gt;), you'll just get single-binary HTTPS with
libsunec.so under the hood, meaning I can finally close
&lt;a href="https://github.com/oracle/graal/issues/1336"&gt;#1336&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Example project&lt;/h2&gt;
&lt;p&gt;I updated &lt;a href="https://github.com/lvh/cljurl-graalvm-demo"&gt;cljurl-graalvm-demo&lt;/a&gt; if you want to try any of
this at home. If you're on Linux and want to debug the TLS issues, I wrote
&lt;a href="https://github.com/lvh/nscap"&gt;nscap&lt;/a&gt; specifically for this purpose. It leverages Linux namespaces to
elegantly capture network traffic for a single process. You can then throw the
resulting PCAP into e.g. wireshark.&lt;/p&gt;
&lt;h2&gt;What I'd still love to see in native-image&lt;/h2&gt;
&lt;p&gt;The compiler is slow. It's in the range of rustc speed: typically faster than
C++, certainly slower than Go. It eats a lot of RAM. It's fine because I don't
iterate on the binary version. I develop Clojure apps targeting native-image as
if they're normal Clojure apps and then eventually run some end-to-end tests on
the binary. But you knocked out my #1 feature so now I have a new one 😊&lt;/p&gt;
&lt;h2&gt;Corrections&lt;/h2&gt;
&lt;p&gt;I previously thought/posted that the locking macro (&lt;a href="https://clojure.atlassian.net/browse/CLJ-1472"&gt;CLJ-1472&lt;/a&gt;)
problems appear to be gone or at least reduced, but I have been unable to
consistently reproduce that and others have reported no change.&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><guid>https://www.lvh.io/posts/clojure-and-native-image-on-jdk-11-flavored-graalvm-1930%2B/</guid><pubDate>Sun, 24 Nov 2019 16:50:15 GMT</pubDate></item><item><title>Solving regex crosswords</title><link>https://www.lvh.io/posts/solving-regex-crosswords/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://regexcrossword.com/"&gt;Regex Crossword&lt;/a&gt; is a puzzle game to help you
practice regular expressions. I wrote a program to solve them. You can find it
on GitHub as &lt;a href="https://github.com/lvh/regex-crossword"&gt;&lt;code&gt;lvh/regex-crossword&lt;/code&gt;&lt;/a&gt;. If
you're on amd64 Linux, you can try the &lt;a href="https://github.com/lvh/regex-crossword/releases/tag/0.1.0"&gt;demo binary too&lt;/a&gt;. This blog post
walks you through how I wrote it using logic programming.&lt;/p&gt;
&lt;p&gt;To me this game feels more like Sudoku than a crossword. When you solve a
crossword, you start by filling out the words you're certain of and use those
answers as hints for the rest. Backtracking is relatively rare. In a sudoku, you
might start by filling out a handful of certain boxes, but in most puzzles you
quickly need to backtrack. That distinction shapes how I think of solving it:
searching and backtracking is a natural fit for logic programming.&lt;/p&gt;
&lt;p&gt;Logic programming is a niche technology, but in its sweet spot it's miraculous.
I'll introduce the concept to help you recognize what sorts of problems it's
good at. Worst case, you'll enjoy a cool hack. Best case you'll get the
satisfaction of writing a beautiful solution to a problem some time in the
future.&lt;/p&gt;
&lt;p&gt;My programming language of choice is Clojure, and Clojure has
&lt;a href="https://github.com/clojure/core.logic"&gt;&lt;code&gt;clojure/core.logic&lt;/code&gt;&lt;/a&gt;, a logic programming library. Because logic
programming is such a specialized tool, it's more useful to have libraries that
let you "drop in to" logic programming than to do everything in a full-blown
logic programming language.&lt;/p&gt;
&lt;h2&gt;Approach&lt;/h2&gt;
&lt;p&gt;It would not be a bad idea to read &lt;a href="https://regexcrossword.com/howtoplay"&gt;the instructions for Regex
Crossword&lt;/a&gt;. I'll also assume you have seen some basic regular
expressions. Hopefully the Clojure will be piecemeal enough you can
just follow along, but reading a tutorial wouldn't hurt.&lt;/p&gt;
&lt;p&gt;Let's take a look at the first beginner puzzle:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://www.lvh.io/img/regex-crossword/beginner1.png" alt="the first regex crossword level in the Beginner set"&gt;
&lt;figcaption&gt;The first level in the Beginner set, &lt;a href="https://regexcrossword.com/challenges/beginner/puzzles/1"&gt;"Beatles"&lt;/a&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Each regex part applies to some number of unknowns (empty boxes). The first row
regex &lt;code&gt;HE|LL|O+&lt;/code&gt; applies to the unknowns of the first row. The first column
regex &lt;code&gt;[^SPEAK]+&lt;/code&gt; applies to the unknowns of the first column. Both constrain
the top left unknown: we're counting on our logic programming engine at being
convenient for expressing that "cascading" of constraints.&lt;/p&gt;
&lt;p&gt;An unknown is just a logic variable in constraint logic programming. For brevity
we'll call them "lvars" (&lt;em&gt;[ell vars]&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Rows, columns (and in later puzzles hexagon lines) are all just layout.
Fundamentally it's all just a regex applying to some lvars.&lt;/p&gt;
&lt;h2&gt;Breaking down regular expressions&lt;/h2&gt;
&lt;p&gt;Most regular expressions have structure, like &lt;code&gt;(AB|CD)XY&lt;/code&gt;. We'll solve this
problem recursively: if &lt;code&gt;(AB|CD)XY&lt;/code&gt; matches lvars &lt;code&gt;p, q, r, s&lt;/code&gt;, then presumably
&lt;code&gt;pq&lt;/code&gt; must match &lt;code&gt;AB|CD&lt;/code&gt; and &lt;code&gt;rs&lt;/code&gt; must match &lt;code&gt;XY&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(There are some counterexamples to the idea that we can solve the entire problem
recursively! For example, backrefs within a regex would require a second pass,
and backrefs across regular expressions would require another top-level pass.
We'll deal with those later. There are ties to language theory here, but that's
a story for another day.)&lt;/p&gt;
&lt;p&gt;We'll parse the regular expression into a data structure that's easier to
handle. Fortunately, there's a piece of code out there that knows how to
generate strings matching a given regex, which has a parser we can reuse. That
parser is designed for Java's regular expression syntax. It's not quite
identical to that of JavaScript, but we're hoping that the puzzles avoid those
tricky edge cases for now.&lt;/p&gt;
&lt;p&gt;To parse, we use &lt;code&gt;[com.gfredericks.test.chuck.regexes :as cre]&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"HE|LL|O+"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt; (read: produces)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\H&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\E&lt;/span&gt;&lt;span class="p"&gt;})}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\L&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\L&lt;/span&gt;&lt;span class="p"&gt;})}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\O&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;,
     &lt;span class="ss"&gt;:bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;]})})}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Progress! It is indeed an alternation (a or b) of a concatenation of H and E, or
L and L, or the letter O one or more times.&lt;/p&gt;
&lt;h2&gt;Logic machinery&lt;/h2&gt;
&lt;p&gt;The logic programming engine is going to search a tree of possibilities for
solutions that fit your constraints. Logic programming is inherently
declarative: instead of telling the computer how to find the answer, we describe
what the answer looks like.&lt;/p&gt;
&lt;p&gt;An lvar that doesn't have a value assigned to it yet (it could still be
anything) is called "fresh". An lvar with a definite value is called "bound".
There is nothing preventing your program from returning fresh variables: that
just means the answer that doesn't rely on what that lvar taking any particular
value (like the &lt;em&gt;x&lt;/em&gt; in &lt;em&gt;0x = 0&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;In core.logic, a program consists of a series of expressions called &lt;em&gt;goals&lt;/em&gt;.
&lt;code&gt;(l/== a b)&lt;/code&gt; is a goal to make the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal. It does not, by
itself, compare &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; or assign anything to anything. It just expresses the
idea of comparing the two. Logic programming calls this "unification".&lt;/p&gt;
&lt;p&gt;As the engine searches the space of possible answers, sometimes &lt;code&gt;a&lt;/code&gt; will be
equal to &lt;code&gt;b&lt;/code&gt; already, or &lt;code&gt;a&lt;/code&gt; will be bound and &lt;code&gt;b&lt;/code&gt; will be fresh in which case
&lt;code&gt;b&lt;/code&gt; will become bound to whatever &lt;code&gt;a&lt;/code&gt; was bound to. Either way, the two
variables can be &lt;em&gt;unified&lt;/em&gt; and the goal is said to &lt;em&gt;succeed&lt;/em&gt;. But in many parts
of the tree this doesn't work out: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will already be bound to
incompatible values. In that case, the goal is said to fail. Unification is just
one of many goals, but it's the most important one in most programs including
ours.&lt;/p&gt;
&lt;p&gt;Finally, we need a way to actually run the logic programming engine. that's
&lt;code&gt;clojure.core.logic/run&lt;/code&gt;'s job. Something like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;            &lt;span class="c1"&gt;;; run to find up to one answer with logic vars [q]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;q&lt;/span&gt; &lt;span class="ss"&gt;'fred&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;;; where q is unified with 'fred&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;... will return &lt;code&gt;('fred)&lt;/code&gt; (the 1-list with the symbol &lt;code&gt;'fred&lt;/code&gt; in it) because
there's only one answer for &lt;code&gt;q&lt;/code&gt; that makes all the goals (here just one goal)
succeed. &lt;code&gt;run&lt;/code&gt; takes the &lt;em&gt;maximum number of answers&lt;/em&gt; as a parameter. Since
you're describing what the answer looks like, there might be zero, one, or any
other number of answers. Sometimes the engine will be able to prove there are no
other options (because the search was exhaustive) and it'll return fewer. Some
programs run forever, some so long it might as well be forever. &lt;code&gt;run&lt;/code&gt; has a
sibling &lt;code&gt;run*&lt;/code&gt; that gets you all the answers. It returns the same result,
because there's only one value for &lt;code&gt;q&lt;/code&gt; that makes all goals succeed.&lt;/p&gt;
&lt;h2&gt;Character match&lt;/h2&gt;
&lt;p&gt;The simplest possible regular expression is just a character, which matches
itself: &lt;code&gt;A&lt;/code&gt;. In our parse tree, this is an entry of &lt;code&gt;:type&lt;/code&gt; &lt;code&gt;:character&lt;/code&gt;. We'll
write a multimethod dispatching on &lt;code&gt;:type&lt;/code&gt; to make this work so we can implement
other types later.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmulti &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;A character looks like this: &lt;code&gt;{:type :character, :character \L}&lt;/code&gt;. We'll use
destructuring to extract the &lt;code&gt;:character&lt;/code&gt; key. In general, this multimethod will
take multiple lvars, though incidentally in the case of &lt;code&gt;:character&lt;/code&gt; it'll
be just one, so we can destructure it as well.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;character&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvar&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;character&lt;/span&gt; &lt;span class="nv"&gt;lvar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We'll write a test to verify this works.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/deftest&lt;/span&gt; &lt;span class="nv"&gt;re-&amp;gt;goal-character-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;])))))&lt;/span&gt;
&lt;/pre&gt;


&lt;h2&gt;Alternation&lt;/h2&gt;
&lt;p&gt;Let's look at a few parse trees for some simple alternations:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A|B"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;, &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;})}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;, &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;})})}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here's an example where the options are different length.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"AAA|B"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;})}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;
   &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;})})}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;It's also probably a good idea to consider something with more than two alternatives:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A|B|C"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;, &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;})}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;, &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;})}&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;, &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\C&lt;/span&gt;&lt;span class="p"&gt;})})}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Note the parser will always create concatenations as elements of alternations
even if the element is really just a single character. We can't handle
concatenations yet, so while we generally prefer things that the parser actually
produces, we'll cheat with an alternation of characters first.&lt;/p&gt;
&lt;h3&gt;Alternation in logic&lt;/h3&gt;
&lt;p&gt;The obvious test to write is:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/deftest&lt;/span&gt; &lt;span class="nv"&gt;re-&amp;gt;goal-alternation-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A|B"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;])))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;... but as we saw above, that introduces concatenations. Instead:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="c1"&gt;;; "A|B" with the internal concatenations removed&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;
                            &lt;span class="ss"&gt;:elements&lt;/span&gt;
                            &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                             &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;}]}&lt;/span&gt;
                           &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt; &lt;span class="sc"&gt;\C&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="c1"&gt;;; "A|B|C" with the internal concatenations removed&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;
                            &lt;span class="ss"&gt;:elements&lt;/span&gt;
                            &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                             &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                             &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\C&lt;/span&gt;&lt;span class="p"&gt;}]}&lt;/span&gt;
                           &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We need a way to express disjunction. Like &lt;code&gt;l/and*&lt;/code&gt;, there's a &lt;code&gt;l/or*&lt;/code&gt;. Once we
have that, alternation is straightforward:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/or*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This primer is a little unorthodox because we're walking through a problem that
requires rule generation. Most introductory texts make you build up static
rules. Disjunction is usually expressed with the macro &lt;code&gt;l/conde&lt;/code&gt;. One difference
is that &lt;code&gt;conde&lt;/code&gt; can express a disjunction of conjunctions in one go:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;conde&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c1"&gt;;; is equivalent to&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or*&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;and*&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;


&lt;h2&gt;Concatenation&lt;/h2&gt;
&lt;p&gt;We want to be able to solve squares, not just individual letters. The simplest
case is a concatenation of two characters, like &lt;code&gt;AA&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;aa&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt; &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/deftest&lt;/span&gt; &lt;span class="nv"&gt;re-&amp;gt;goal-concatenation-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt; &lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;aa&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt; &lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;])))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;A simple implementation passes this test:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;
                &lt;span class="nv"&gt;v&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;(&lt;code&gt;l/and*&lt;/code&gt;is a function that returns a goal that succeeds when all its goals
succeed. We'd use the macro version &lt;code&gt;l/all&lt;/code&gt; if we were explicitly writing out
our goals. Because we're generating them, it's easier to use a function.)&lt;/p&gt;
&lt;p&gt;We're clearly abusing the fact that we happen to know that the parts are
characters and therefore length 1. But the parts could be repetitions, or an
alternation between concatenations each of length &amp;gt;1.&lt;/p&gt;
&lt;h3&gt;Distributing lvars over groups&lt;/h3&gt;
&lt;p&gt;Next, we need to find the ways lvars can be distributed over the individual
elements. We know that each lvar represents a square and each square must be
assigned, so we know that the sum of the lengths of the elements must be the
total number of lvars.&lt;/p&gt;
&lt;p&gt;We can actually solve this sub-problem using logic programming as well! We'll
use CLP(FD), which means "constraint logic programming over finite domains".&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; [clojure.core.logic.fd :as f]&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/fresh&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f/in&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f/interval&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f/eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="c1"&gt;;; =&amp;gt; ([2 3 5] [3 2 5] [2 4 4] [2 5 3] [4 2 4] [3 3 4]&lt;/span&gt;
&lt;span class="c1"&gt;;;     [3 4 3] [5 2 3] [4 3 3] [3 5 2] [4 4 2] [5 3 2])&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As mentioned before, the approach we've taken to this problem is unique because
we're &lt;em&gt;generating&lt;/em&gt; rules. Most logic programs have a static structure and
dynamic data, while our data informs the structure itself. We need to know how
many groups there are to know how many lvars to create with &lt;code&gt;fresh&lt;/code&gt;. &lt;code&gt;f/eq&lt;/code&gt; is
itself a convenience macro that rewrites "normal" Lisp-style equations (like &lt;code&gt;(=
10 (+ x y z))&lt;/code&gt;) to a form the logic engine knows how to solve directly.&lt;/p&gt;
&lt;p&gt;One way to solve that problem is with macros and &lt;code&gt;eval&lt;/code&gt;, but that might impede our
ability to port to e.g. ClojureScript and native-image. Plus, I wanted to learn
more about how the finite domain magic works internally.&lt;/p&gt;
&lt;p&gt;The main thing &lt;code&gt;f/eq&lt;/code&gt; does here is introduce intermediate variables. The
underlying goal &lt;code&gt;f/+&lt;/code&gt; only takes 3 arguments: two summands and a sum result. To
express a sum over many summands you need intermediate "running total" lvars. I
wrote that:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;reduceo&lt;/span&gt;
  &lt;span class="s"&gt;"Given a binary operator goal, return an n-ary one.&lt;/span&gt;

&lt;span class="s"&gt;  If the given goal has shape `(⊕ x y z)` meaning `x ⊕ y = z`, `(reduceo ⊕ z&lt;/span&gt;
&lt;span class="s"&gt;  vars)` computes `z = vars[0] ⊕ vars[1] ⊕ vars[2]...`."&lt;/span&gt;
  &lt;span class="c1"&gt;;; lower case are input vars (a, b, c, d...)&lt;/span&gt;
  &lt;span class="c1"&gt;;; upper case are intermediate accumulator lvars ("running totals")&lt;/span&gt;
  &lt;span class="c1"&gt;;; Ω is the final result&lt;/span&gt;
  &lt;span class="c1"&gt;;;     a ⊕ b = A&lt;/span&gt;
  &lt;span class="c1"&gt;;;     A ⊕ c = B&lt;/span&gt;
  &lt;span class="c1"&gt;;;       ...&lt;/span&gt;
  &lt;span class="c1"&gt;;;     W ⊕ y = X&lt;/span&gt;
  &lt;span class="c1"&gt;;;     X ⊕ z = Ω&lt;/span&gt;
  &lt;span class="c1"&gt;;;     |   |   |&lt;/span&gt;
  &lt;span class="c1"&gt;;;     |   |   \_ (concat accumulators (list result))&lt;/span&gt;
  &lt;span class="c1"&gt;;;     |   \_ (rest lvars)&lt;/span&gt;
  &lt;span class="c1"&gt;;;     \_ (cons (first lvars) (butlast accumulators))&lt;/span&gt;
  &lt;span class="c1"&gt;;;&lt;/span&gt;
  &lt;span class="c1"&gt;;; There are two fewer accumulators than there are input lvars. The middle&lt;/span&gt;
  &lt;span class="c1"&gt;;; equations all use 2 accumulators each: one to carry the previous result and&lt;/span&gt;
  &lt;span class="c1"&gt;;; one to carry it to the next equation. The first equation uses 2 input vars&lt;/span&gt;
  &lt;span class="c1"&gt;;; and 1 accumulator, and the last equation uses 1 input var, 1 accumulator&lt;/span&gt;
  &lt;span class="c1"&gt;;; and the result (which may be an lvar, but it's not _our_ lvar -- and in&lt;/span&gt;
  &lt;span class="c1"&gt;;; common uses we expect it to be a normal value).&lt;/span&gt;
  &lt;span class="c1"&gt;;;&lt;/span&gt;
  &lt;span class="c1"&gt;;; We don't need the butlast because map will only use the shortest coll argument.&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;binop&lt;/span&gt; &lt;span class="nv"&gt;result&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;results&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repeatedly&lt;/span&gt; &lt;span class="nv"&gt;l/lvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;lefts &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;results&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;rights &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;binop&lt;/span&gt; &lt;span class="nb"&gt;lefts rights &lt;/span&gt;&lt;span class="nv"&gt;results&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This lets us define a sum goal and a helper function that runs the logic engine
for us to find all the ways we can sum up to a number, with some bounds:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;sumo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;partial &lt;/span&gt;&lt;span class="nv"&gt;reduceo&lt;/span&gt; &lt;span class="nv"&gt;f/+&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;summands&lt;/span&gt;
  &lt;span class="s"&gt;"Find ways you can add some numbers up to a given total.&lt;/span&gt;

&lt;span class="s"&gt;  For each number (summand) provide bounds `[min max]` or `nil` if you don't&lt;/span&gt;
&lt;span class="s"&gt;  know. Possible assignments are returned in the same order."&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repeatedly&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;l/lvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;bounds-goals&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;map&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;min &lt;/span&gt;&lt;span class="nv"&gt;max&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f/in&lt;/span&gt; &lt;span class="nv"&gt;v&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f/interval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or min &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or max &lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
                      &lt;span class="nv"&gt;lvars&lt;/span&gt; &lt;span class="nv"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;q&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="nv"&gt;bounds-goals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sumo&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Finally we need a way to use these weights to partition up a collection:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;partition-by-weights&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;weights&lt;/span&gt; &lt;span class="nv"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;rest-weights&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;weights&lt;/span&gt;
         &lt;span class="nv"&gt;coll&lt;/span&gt; &lt;span class="nv"&gt;coll&lt;/span&gt;
         &lt;span class="nv"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;[]]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;some?&lt;/span&gt; &lt;span class="nv"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;
       &lt;span class="nv"&gt;rest-weights&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;drop &lt;/span&gt;&lt;span class="nv"&gt;weight&lt;/span&gt; &lt;span class="nv"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take &lt;/span&gt;&lt;span class="nv"&gt;weight&lt;/span&gt; &lt;span class="nv"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;There's an alternative way to write this using &lt;code&gt;appendo&lt;/code&gt;: &lt;code&gt;(l/appendo a b c)&lt;/code&gt; is
like &lt;code&gt;append&lt;/code&gt; but for lvars. You can create a version that supports multiple
lists (let's call it &lt;code&gt;concato&lt;/code&gt;) using the same machinery:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;concato&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;partial &lt;/span&gt;&lt;span class="nv"&gt;reduceo&lt;/span&gt; &lt;span class="nv"&gt;l/appendo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In a sense &lt;code&gt;concato&lt;/code&gt; is more direct: the lists are the lists you want, there's
no &lt;code&gt;partition-by-weights&lt;/code&gt; to translate from your numeric answer to the list
partitions you need. With all of these goals in place we can implement
concatenation. We find each possible weight distribution, and for each
distribution, each group must match that set of lvars.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;n-elems&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n-vars&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/or*&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;weights&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;summands&lt;/span&gt; &lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;repeat &lt;/span&gt;&lt;span class="nv"&gt;n-elems&lt;/span&gt; &lt;span class="nv"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="ss"&gt;:let&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvar-groups&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;partition-by-weights&lt;/span&gt; &lt;span class="nv"&gt;weights&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)]]&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt; &lt;span class="nv"&gt;lvar-groups&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;h2&gt;Fixing :character&lt;/h2&gt;
&lt;p&gt;What the concatenation problem tells us is that character is broken, too.
Concatenation may attempt to assign 2 lvars to a single character. Right now,
that returns a goal unifying the first lvar with that character: if there were
more, the remaining lvars would simply go unconstrained:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;character&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvar&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;character&lt;/span&gt; &lt;span class="nv"&gt;lvar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We communicate a problem with a failing goal. If some goal fails, the engine
will stop exploring that branch. The always-failing goal &lt;code&gt;l/fail&lt;/code&gt; is designed
for this sort of thing. (You can probably guess what its counterpart &lt;code&gt;l/succeed&lt;/code&gt;
does.) The amended version looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;character&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvar&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;character&lt;/span&gt; &lt;span class="nv"&gt;lvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;l/fail&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You could also do this in logic programming so that it's checked at runtime, but
since we're generating our goals ahead of time here and only giving them to the
engine at the end, we can short-circuit here.&lt;/p&gt;
&lt;h2&gt;Repetition&lt;/h2&gt;
&lt;h3&gt;Sample repetition parses&lt;/h3&gt;
&lt;p&gt;Let's see what the parser does for a few simple repetitions:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A{1}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;,
     &lt;span class="ss"&gt;:bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="nv"&gt;N&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="nv"&gt;N&lt;/span&gt;&lt;span class="p"&gt;]})})}&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A{1,}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;,
     &lt;span class="ss"&gt;:bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="nv"&gt;N&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;]})})}&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A{1,2}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;,
     &lt;span class="ss"&gt;:bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="nv"&gt;N&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="nv"&gt;N&lt;/span&gt;&lt;span class="p"&gt;]})})}&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;,
     &lt;span class="ss"&gt;:bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;]})})}&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"A+"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:character&lt;/span&gt;, &lt;span class="ss"&gt;:character&lt;/span&gt; &lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;,
     &lt;span class="ss"&gt;:bounds&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;]})})}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This matches our expectation, since:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A{n}&lt;/code&gt; means exactly &lt;em&gt;n&lt;/em&gt; A's&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A{m,n}&lt;/code&gt; means between &lt;em&gt;m&lt;/em&gt; and &lt;em&gt;n&lt;/em&gt; A's, inclusive&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A{n,}&lt;/code&gt; means &lt;code&gt;n&lt;/code&gt; or more A's&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A*&lt;/code&gt; means 0 or more A's&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A+&lt;/code&gt; means 1 or more A's&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"No bound" is represented by &lt;code&gt;nil&lt;/code&gt;. Some numbers are represented as just &lt;code&gt;1&lt;/code&gt;,
others as &lt;code&gt;1N&lt;/code&gt;. The latter are &lt;code&gt;clojure.lang.BigInts&lt;/code&gt;, not longs. The parser
does this so it can support regexes with pathologically large sizes (longer than
a &lt;code&gt;long&lt;/code&gt;, a signed 64-bit integer). We can ignore that distinction: both behave
identically for our purposes.&lt;/p&gt;
&lt;h3&gt;Implementing repetition&lt;/h3&gt;
&lt;p&gt;Repetition has a generalization of the &lt;code&gt;:character&lt;/code&gt; behavior we fixed earlier TKTK multiple vars&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:repetition&lt;/span&gt;
  &lt;span class="p"&gt;[{[&lt;/span&gt;&lt;span class="nv"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lower&lt;/span&gt; &lt;span class="nv"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ss"&gt;:bounds&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;lower&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;lower&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;upper&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;upper&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or &lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;max &lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="c1"&gt;;; Even though e.g. the empty string matches "A*", we get the lvars from the&lt;/span&gt;
    &lt;span class="c1"&gt;;; structure of the puzzle, so we know all lvars have to be matched.&lt;/span&gt;

    &lt;span class="c1"&gt;;; Consequence 1: 0 reps only works if there are 0 vars to match.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;l/succeed&lt;/span&gt; &lt;span class="nv"&gt;l/fail&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/or*&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;reps&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;max &lt;/span&gt;&lt;span class="nv"&gt;lower&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;inc &lt;/span&gt;&lt;span class="nv"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="c1"&gt;;; Consequence 2: can't have any leftovers: must match all parts&lt;/span&gt;
             &lt;span class="ss"&gt;:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rem &lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="nv"&gt;reps&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="ss"&gt;:let&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;group-size&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;quot &lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="nv"&gt;reps&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="nv"&gt;groups&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;partition&lt;/span&gt; &lt;span class="nv"&gt;group-size&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)]]&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;partial &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;h2&gt;Trying to solve a few puzzles&lt;/h2&gt;
&lt;p&gt;We've done quite a bit of work but still haven't solved any real puzzles. We'd
like to solve the game's own puzzles, so let's start from its internal
representation. Remember the first puzzle from the beginner set:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://www.lvh.io/img/regex-crossword/beginner1.png" alt="the first regex crossword level in the Beginner set"&gt;
&lt;figcaption&gt;The first level in the Beginner set, &lt;a href="https://regexcrossword.com/challenges/beginner/puzzles/1"&gt;"Beatles"&lt;/a&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Its internal representation looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ jq &lt;span class="s1"&gt;'.[1].puzzles[0]'&lt;/span&gt; challenges.json
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"id"&lt;/span&gt;: &lt;span class="s2"&gt;"475e811a-da59-4ce8-9b80-3124b33cc041"&lt;/span&gt;,
  &lt;span class="s2"&gt;"name"&lt;/span&gt;: &lt;span class="s2"&gt;"Beatles"&lt;/span&gt;,
  &lt;span class="s2"&gt;"patternsX"&lt;/span&gt;: &lt;span class="o"&gt;[&lt;/span&gt;
    &lt;span class="o"&gt;[&lt;/span&gt;
      &lt;span class="s2"&gt;"[^SPEAK]+"&lt;/span&gt;
    &lt;span class="o"&gt;]&lt;/span&gt;,
    &lt;span class="o"&gt;[&lt;/span&gt;
      &lt;span class="s2"&gt;"EP|IP|EF"&lt;/span&gt;
    &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;]&lt;/span&gt;,
  &lt;span class="s2"&gt;"patternsY"&lt;/span&gt;: &lt;span class="o"&gt;[&lt;/span&gt;
    &lt;span class="o"&gt;[&lt;/span&gt;
      &lt;span class="s2"&gt;"HE|LL|O+"&lt;/span&gt;
    &lt;span class="o"&gt;]&lt;/span&gt;,
    &lt;span class="o"&gt;[&lt;/span&gt;
      &lt;span class="s2"&gt;"[PLEASE]+"&lt;/span&gt;
    &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;(We'll turn the keys to kebab-case-keywords so it looks a bit more Clojure-y.)
There's something strange about the sample data: &lt;code&gt;:patterns-x&lt;/code&gt; and &lt;code&gt;:patterns-y&lt;/code&gt;
are both seqs of seqs of patterns. You may have expected them to be seqs of
patterns directly. This data structure choice isn't obvious until you hit a
later puzzle such as the first level in the "Double Cross" set:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://www.lvh.io/img/regex-crossword/doublecross.png" alt="the first regex crossword level in the Double Cross set"&gt;
&lt;figcaption&gt;The first level in the Double Cross set, &lt;a href="https://regexcrossword.com/challenges/doublecross/puzzles/1"&gt;"Telekinesis"&lt;/a&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;This puzzle is represented internally as:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="s"&gt;"f0f06b00-ec0a-4572-935d-7459e2a13064"&lt;/span&gt;
 &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="s"&gt;"Telekinesis"&lt;/span&gt;
 &lt;span class="ss"&gt;:patterns-x&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;"[D-HJ-M]"&lt;/span&gt; &lt;span class="s"&gt;"[^F-KM-Z]"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"[^A-RU-Z]"&lt;/span&gt; &lt;span class="s"&gt;"[A-KS-V]"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
 &lt;span class="ss"&gt;:patterns-y&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;"[A-GN-Z]+"&lt;/span&gt; &lt;span class="s"&gt;"[^A-DI-S]+"&lt;/span&gt;&lt;span class="p"&gt;]]}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see this just represents different patterns affecting the same row.
Ironically while this is presumably intended to make the puzzle harder, the
extra constraints probably just make the logic engine's life easier. Either way,
solving means we make some lvars for each box, carve them up by rows and
columns, and then apply the regex goals:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;solve&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;puzzle&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;solve&lt;/span&gt; &lt;span class="nv"&gt;puzzle&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;([{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;patterns-x&lt;/span&gt; &lt;span class="nv"&gt;patterns-y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;puzzle&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;opts&lt;/span&gt; &lt;span class="ss"&gt;:or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;}}]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;patterns-x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;patterns-y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="nv"&gt;vars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repeatedly&lt;/span&gt; &lt;span class="nv"&gt;n-vars&lt;/span&gt; &lt;span class="nv"&gt;l/lvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="nv"&gt;rows&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;partition&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;patterns-x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="nv"&gt;cols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;mapv&lt;/span&gt; &lt;span class="nb"&gt;vector &lt;/span&gt;&lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="nv"&gt;pattern-goals&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;map&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;patterns&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt;
                           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;cre/parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;patterns&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="nv"&gt;patterns-x&lt;/span&gt; &lt;span class="nv"&gt;patterns-y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="nv"&gt;cols&lt;/span&gt; &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;q&lt;/span&gt; &lt;span class="nv"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="nv"&gt;pattern-goals&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We can use this to solve the first tutorial puzzle:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;solve&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="s"&gt;"272901bb-0855-4157-9b45-272935da8c93"&lt;/span&gt;
  &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="s"&gt;"The OR symbol"&lt;/span&gt;
  &lt;span class="ss"&gt;:patterns-x&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;"A|B"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="ss"&gt;:patterns-y&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;"A|Z"&lt;/span&gt;&lt;span class="p"&gt;]]})&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt; (((\A)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Unfortunately, the second one has character classes, so we have to implement
that next.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="s"&gt;"6915fafc-3323-484d-b801-5daac73ddb56"&lt;/span&gt;
 &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="s"&gt;"A Range of characters"&lt;/span&gt;
 &lt;span class="ss"&gt;:patterns-x&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;"[ABC]"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
 &lt;span class="ss"&gt;:patterns-y&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;"[BDF]"&lt;/span&gt;&lt;span class="p"&gt;]]}&lt;/span&gt;
&lt;/pre&gt;


&lt;h2&gt;Character classes&lt;/h2&gt;
&lt;p&gt;Let's look at another parse:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cre/parse&lt;/span&gt; &lt;span class="s"&gt;"[A]"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:alternation&lt;/span&gt;,
 &lt;span class="ss"&gt;:elements&lt;/span&gt;
 &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:concatenation&lt;/span&gt;,
   &lt;span class="ss"&gt;:elements&lt;/span&gt;
   &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class&lt;/span&gt;,
     &lt;span class="ss"&gt;:elements&lt;/span&gt;
     &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-intersection&lt;/span&gt;,
       &lt;span class="ss"&gt;:elements&lt;/span&gt;
       &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-union&lt;/span&gt;
         &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}]}]}]&lt;/span&gt;
     &lt;span class="ss"&gt;:brackets?&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;}]}]}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Whoa! This parses to something a lot trickier than you might've guessed. Class
sets (intersections, unions and subtraction) are somewhat obscure set of regex
features with slightly differing support across platforms and slightly different
syntax. They're particularly useful when you have a full Unicode regex engine
and you want to say things like "match characters in this script, but not digits
or punctuation". In Java, Ruby and Python, they are spelled something like
&lt;code&gt;[α&amp;amp;&amp;amp;[β]&amp;amp;&amp;amp;[γ]]&lt;/code&gt; where &lt;code&gt;αβγ&lt;/code&gt; are all their own class specs.&lt;/p&gt;
&lt;p&gt;This is a side-effect of using a parser intended for parsing Java regular
expressions. JavaScript doesn't support these features. Fortunately, they're
pretty easy to implement. As usual, we'll tackle the simple base case first.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;


&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;chars&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvar&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="c1"&gt;;; It appears class-base will only ever have one char, but I'm writing this&lt;/span&gt;
  &lt;span class="c1"&gt;;; defensively since I have no proof I've exhausted all the parser cases.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/membero&lt;/span&gt; &lt;span class="nv"&gt;lvar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;vec&lt;/span&gt; &lt;span class="nv"&gt;chars&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;;; vec, bc membero doesn't work with sets&lt;/span&gt;
    &lt;span class="nv"&gt;l/fail&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;h3&gt;Class union and intersection&lt;/h3&gt;
&lt;p&gt;While we could cheat implementing class union and intersection since the
original JavaScript puzzle would never have them, they're trivial to express in
logic, so let's just do them properly:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/testing&lt;/span&gt; &lt;span class="s"&gt;"class-union"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt;
              &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-union&lt;/span&gt;
               &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}]}&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt;
              &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-union&lt;/span&gt;
               &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
                          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;}}]}&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;])))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/testing&lt;/span&gt; &lt;span class="s"&gt;"class-intersection"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt;
              &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-intersection&lt;/span&gt;
               &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}]}&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt;
              &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-intersection&lt;/span&gt;
               &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
                          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}]}&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt;
              &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-intersection&lt;/span&gt;
               &lt;span class="ss"&gt;:elements&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
                          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;:class-base&lt;/span&gt; &lt;span class="ss"&gt;:chars&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;\B&lt;/span&gt;&lt;span class="p"&gt;}}]}&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;])))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Implemented by:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:class-union&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/or*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:class-intersection&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;h3&gt;Ranges&lt;/h3&gt;
&lt;p&gt;You're probably catching on. Implementing ranges uses a bunch of logic machinery
we already use, and just a Clojure description of what a range &lt;em&gt;is&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t/is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt; &lt;span class="sc"&gt;\B&lt;/span&gt; &lt;span class="sc"&gt;\C&lt;/span&gt; &lt;span class="sc"&gt;\D&lt;/span&gt; &lt;span class="sc"&gt;\E&lt;/span&gt; &lt;span class="sc"&gt;\F&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/run*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="s"&gt;"[A-F]"&lt;/span&gt; &lt;span class="nv"&gt;cre/parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rcl/re-&amp;gt;goal&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;&lt;span class="p"&gt;])))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Implemented by:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:range&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lvar&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;lvars&lt;/span&gt; &lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;lower&lt;/span&gt; &lt;span class="nv"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp int &lt;/span&gt;&lt;span class="ss"&gt;:character&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="nv"&gt;chars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map char &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;lower&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;inc &lt;/span&gt;&lt;span class="nv"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/membero&lt;/span&gt; &lt;span class="nv"&gt;lvar&lt;/span&gt; &lt;span class="nv"&gt;chars&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nv"&gt;l/fail&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Because ranges like &lt;code&gt;A-Z0-9&lt;/code&gt; are implemented using &lt;code&gt;:class-union&lt;/code&gt;, they just
magically work.&lt;/p&gt;
&lt;h3&gt;Simple classes&lt;/h3&gt;
&lt;p&gt;"Simple classes" are things like &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;. You know how to implement
these already.&lt;/p&gt;
&lt;h2&gt;Class negation&lt;/h2&gt;
&lt;p&gt;Class negation is actually surprisingly tricky! Many logic systems, core.logic
included, focus on positive statements. There is support for disunification
(e.g. this lvar will never be 5) with &lt;code&gt;l/!=&lt;/code&gt;. There's also more general support
for negation as a constraint, as used here:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:class-negation&lt;/span&gt;
    &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/nafc&lt;/span&gt; &lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Unfortunately nafc is marked as experimental and for good reason. For one, it
only works if the vars are ground. Docstring claims execution will be delayed if
they aren't... but that doesn't appear to be true. See
&lt;a href="https://clojure.atlassian.net/browse/LOGIC-172"&gt;LOGIC-172&lt;/a&gt; for details. This
problem annoyingly surfaced depending on the order clauses were evaluated in
(since that changed if they were ground or not). I was able to get it to work
consistently by adding a hack to make sure the vars are ground, and adding a
test to make sure it would work even if this was the first clause:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="ss"&gt;:class-negation&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;neg-goal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/nafc&lt;/span&gt; &lt;span class="nv"&gt;re-&amp;gt;goal&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int &lt;/span&gt;&lt;span class="sc"&gt;\A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;inc &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int &lt;/span&gt;&lt;span class="sc"&gt;\Z&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;ground-hack&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/and*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt; &lt;span class="nv"&gt;lvars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/membero&lt;/span&gt; &lt;span class="nv"&gt;v&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/all&lt;/span&gt; &lt;span class="nv"&gt;ground-hack&lt;/span&gt; &lt;span class="nv"&gt;neg-goal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;A different way to implement this would be to walk this part of the parse tree
manually. Once you find a negation, you look at the rest of the parse tree and
aggregate all the classes it covers. Then, you use plain negation
(disunification), which has no caveats. This is what I ended up implementing; if
you're interested you can read the details &lt;a href="https://github.com/lvh/regex-crossword/blob/fd00aa5f97f285c2bcf4c539144e96d18573f755/src/lvh/regex_crossword/logic.clj#L99"&gt;in the implementation&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Backrefs&lt;/h2&gt;
&lt;p&gt;Backreferences are an interesting challenge because so far we've just assumed we
can recurisvely turn the regex parse tree into goals piecemeal, and backrefs
break that assumption: they necessarily depend on a totally different part of
the parse tree. There are two ways to address that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Change the implementation to produce a data structure instead of logic goals
   directly, and then do something eval-like later to turn the data structure
   into goals&lt;/li&gt;
&lt;li&gt;Cheat and introduce side effects to propagate within the tree walk.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first is clearly the "good" answer. It would also enable other improvements,
like tree-level performance optimization. It's also a good chunk of work, and I
had spent enough time on this weekend project already. So, instead, I did the
hacky side-effecty version. This turned out to be tricky to implement not from a
logic perspective (that part is easy) but because the underlying parser I had
forklifted was from a project that didn't support backrefs, and so it didn't
bother to parse them out correctly. You can see how I hacked around that &lt;a href="https://github.com/lvh/regex-crossword/blob/fd00aa5f97f285c2bcf4c539144e96d18573f755/src/lvh/regex_crossword/logic.clj#L126"&gt;in the
implementation&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This introduction was a little unorthodox. Most texts focus on introducing
different primitives, have you write small static rules and build up from there.
You'll see &lt;code&gt;conde&lt;/code&gt; long before anyone talks to you about &lt;code&gt;or*&lt;/code&gt;.
Negation-as-failure, which we used for classes, is exotic and non-relational.
The way we implemented backrefs works but is inelegant. That's all just a
consequence of the problem we solved, not a principled stance on how to use
&lt;code&gt;core.logic&lt;/code&gt; let alone teach it. Reading &lt;a href="https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992"&gt;The Little Schemer&lt;/a&gt; is still a
good idea if you want to learn to write your own programs.&lt;/p&gt;
&lt;p&gt;(If you want a logic program where the goals are not fixed in advance, you might
want to just stick to the JVM so there are no restrictions on eval use. I
haven't tried running core.logic on &lt;a href="https://github.com/borkdude/sci"&gt;sci&lt;/a&gt;.)&lt;/p&gt;
&lt;h2&gt;Next steps&lt;/h2&gt;
&lt;p&gt;These are things I thought were neat but didn't make sense in the original text.&lt;/p&gt;
&lt;h3&gt;Running programs backwards&lt;/h3&gt;
&lt;p&gt;A truly mind-bending feature of relational programs is that they can be ran
"backwards". Usually, you write a program "forwards": it has some inputs and you
expect some outputs. If you write your logic program a particular way, it
doesn't actually know what's an input and what's an output, and so you can give
it an "output" and it will come up with "inputs" that would have led to that
output. This post did not demonstrate that, but it's one of the better hooks
I've found to get people excited about logic programming. I could not give this
talk better than &lt;a href="https://www.youtube.com/watch?v=RVDCRlW1f1Y"&gt;Will Byrd presenting miniKanren&lt;/a&gt;. I won't spoil the
ending, but go watch that talk.&lt;/p&gt;
&lt;p&gt;Our program does not work that way. All our "inputs" are rules, all our lvars
are the same kind (unknown boxes), so running it "backwards" doesn't really mean
anything. It could, if our parser and rule generation were also fully
relational. In that case, we could fill out some boxes and our program would
tell us progressively more creative regular expressions that would match them.
Instead of a puzzle solver, we would have written a puzzle creator.&lt;/p&gt;
&lt;h3&gt;Palindromes&lt;/h3&gt;
&lt;p&gt;Some puzzles have hints that help you solve them. Usually they're thematic cues,
(e.g. "Hamlet") which are hard to tell a logic engine about. Structural cues are
easy. For example, if you think some lines should be palindromes, you can just
add the following constraint:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/all*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;l/==&lt;/span&gt; &lt;span class="nv"&gt;vars&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse &lt;/span&gt;&lt;span class="nv"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="nv"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If evaluated at the right time, this should constrain the search tree. It's
tricky to make sure that happens without measurement and fiddling.&lt;/p&gt;
&lt;h3&gt;Thematic cues&lt;/h3&gt;
&lt;p&gt;If you really wanted to add thematic cues, e.g. "Hamlet", you could grab the
Wikipedia page, use something like TF/IDF to find important words, filter by the
appropriate size, and introduce them as constraints. I don't expect this will
speed anything up much even if you discount the initial step.&lt;/p&gt;
&lt;h3&gt;Hexagon shaped puzzles&lt;/h3&gt;
&lt;p&gt;I made these work, but didn't hook it up to the solver permanently (mostly
because I lost interest). I like hex grids a lot, but they're not interesting
from a logic perspective so I didn't cover them in this post. You can check out
&lt;a href="https://github.com/lvh/regex-crossword/blob/master/src/lvh/regex_crossword/slices.clj"&gt;the implementation&lt;/a&gt; but be warned: it's mostly just some tedious bean
counting.&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><guid>https://www.lvh.io/posts/solving-regex-crosswords/</guid><pubDate>Sat, 26 Oct 2019 02:36:29 GMT</pubDate></item><item><title>Smaller Clojure Docker builds with multi-stage builds</title><link>https://www.lvh.io/posts/smaller-clojure-docker-builds-with-multi-stage-builds/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;A common pattern in Docker is to use a separate build environment from the
runtime environment. Many platforms have different requirements when you're
generating a runnable artifact than when you're running it.&lt;/p&gt;
&lt;p&gt;In languages like Go, Rust or C, where the most common implementations produce
native binaries, the resulting artifact may require nothing from the environment
at all, or perhaps as little as a C standard library. Even in languages like
Python that don't typically have a build step, you might indirectly use code
that still requires compilation. Common examples include OpenSSL with
pyca/cryptography or NETLIB and other numerical libraries with numpy/scipy.&lt;/p&gt;
&lt;p&gt;In Clojure, you can easily build "uberjars" with both lein and boot. These are
jars (the standard JVM deployable artifact) that come with all dependencies
prepackaged, requiring nothing beyond what's in the Java standard library
(rt.jar). While this still requires a JRE to run, that is still much smaller
than the full development environment.&lt;/p&gt;
&lt;p&gt;There are a few advantages to separating environments. It all boils down to them
not having anything in them they don't need. That has clear performance
advantages, although Docker has historically mitigated this problem with layered
pulls. It can have security benefits as well: you can't have bugs in software
you don't ship. Even software that isn't directly used in the build process can
be affected: some build environments will contain plenty of software that is
never used that would normally carry over into your production environments.&lt;/p&gt;
&lt;p&gt;Historically, most users of Docker haven't bothered. Even if there are
advantages, they aren't worth the hassle of having separate Docker environments
and ferrying data between them. While different ways of effectively sharing data
between containers have been available for years, people who wanted a shared
build step have mostly had to write their own tooling. For example,
my &lt;a href="https://github.com/lvh/icecap/blob/master/utils/build-libsodium-package.sh"&gt;icecap&lt;/a&gt; project has a batch file with an embedded Dockerfile that builds
libsodium debs.&lt;/p&gt;
&lt;p&gt;The upcoming release of Docker will add support for a new feature called
multi-stage builds, where this pattern is much simpler. Dockerfiles themselves
know about your precursor environments now, and future containers have full
access to previous containers for copying build artifacts around. This
requires Docker 17.05 or newer.&lt;/p&gt;
&lt;p&gt;Here's an example Dockerfile that builds an uberjar from a standard lein-based
app, and puts it in a new JRE image:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;FROM clojure AS build-env
WORKDIR /usr/src/myapp
COPY project.clj /usr/src/myapp/
RUN lein deps
COPY . /usr/src/myapp
RUN mv "$(lein uberjar | sed -n 's/^Created \(.*standalone\.jar\)/\1/p')" myapp-standalone.jar

FROM openjdk:8-jre-alpine
WORKDIR /myapp
COPY --from=build-env /usr/src/myapp/myapp-standalone.jar /myapp/myapp.jar
ENTRYPOINT ["java", "-jar", "/myapp/myapp.jar"]
&lt;/pre&gt;


&lt;p&gt;This captures the uberjar name from the &lt;code&gt;lein uberjar&lt;/code&gt; output. If your uberjar
name doesn't end in &lt;code&gt;.standalone.jar&lt;/code&gt;, that won't work. You can change the name
of the uberjar with the &lt;code&gt;:uberjar-name&lt;/code&gt; setting in &lt;code&gt;project.clj&lt;/code&gt;. If you set it
to &lt;code&gt;myapp-standalone.jar&lt;/code&gt;, you don't need the gnarly &lt;code&gt;sed&lt;/code&gt; expression anymore at
all, and can just call &lt;code&gt;lein uberjar&lt;/code&gt;. (Thanks to Łukasz Korecki for the
suggestion!)&lt;/p&gt;
&lt;p&gt;The full clojure base image is a whopping 629MB (according to &lt;code&gt;docker images&lt;/code&gt;),
whereas &lt;code&gt;openjdk:8-jre-alpine&lt;/code&gt; clocks in at 81.4MB. That's a little bit of an
unfair comparison: &lt;code&gt;clojure&lt;/code&gt; also has an alpine-based image. However, this still
illustrates the savings compared to the most commonly used Docker image.&lt;/p&gt;
&lt;p&gt;There are still good reasons for not using multi-stage builds. In the icecap
example above, the entire point is to use Docker as a build system to produce
a deb artifact &lt;em&gt;outside of Docker&lt;/em&gt;. However, that's a pretty exotic use case:
for most people this will hopefully make smaller Docker images an easy
reality.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edited:&lt;/em&gt; The original blog post said that the Docker version to support this
feature was in beta at time of writing. That was/is correct, but it's since
been released, so I updated the post.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edited:&lt;/em&gt;* Łukasz Korecki pointed out that &lt;code&gt;project.clj&lt;/code&gt; has an &lt;code&gt;:uberjar-name&lt;/code&gt;
parameter which can be used to avoid the gnarly &lt;code&gt;sed&lt;/code&gt; expression. Thanks Łukasz!&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><category>docker</category><guid>https://www.lvh.io/posts/smaller-clojure-docker-builds-with-multi-stage-builds/</guid><pubDate>Fri, 16 Jun 2017 17:12:46 GMT</pubDate></item><item><title>What the heck is a clojure.lang.IFn$LO?</title><link>https://www.lvh.io/posts/what-the-heck-is-a-clojurelangifnlo/</link><dc:creator>lvh</dc:creator><description>&lt;div&gt;&lt;p&gt;It's no secret that I love Clojure. Like any tool though, it isn't
perfect. Today, I was trying to write unit tests that use
&lt;code class="docutils literal"&gt;clojure.core.async/timeout&lt;/code&gt;, so I wrote a test double analogous to
Twisted's &lt;code class="docutils literal"&gt;Clock&lt;/code&gt;. As I tried to &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;with-redefs&lt;/span&gt;&lt;/code&gt; it in, I got the
most inscrutable error message out: &lt;code class="docutils literal"&gt;java.lang.ClassCastException:
icecap.handlers.delay_test$fake_timeout$timeout__22934 cannot be cast
to clojure.lang.IFn$LO&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wha? I know &lt;code class="docutils literal"&gt;clojure.lang.IFn&lt;/code&gt;, Clojure's function type, but what
the heck is a &lt;code class="docutils literal"&gt;clojure.lang.IFn$LO&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Searching for the term didn't give any particularly useful results. It
was clear this happened when I was redeffing the original &lt;code class="docutils literal"&gt;timeout&lt;/code&gt;,
so I looked at its documentation:&lt;/p&gt;
&lt;pre class="literal-block"&gt;clojure.core.async/timeout
([msecs])
Returns a channel that will close after msecs&lt;/pre&gt;
&lt;p&gt;Doesn't look too special to me. What's the type of that thing, anyway?
Let's find out:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type timeout))
#{clojure.lang.IFn$LO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;Aha! So that is actually part of &lt;code class="docutils literal"&gt;timeout&lt;/code&gt;, not something else wonky
going on. What does the source say? It's a pretty lame shim:&lt;/p&gt;
&lt;pre class="literal-block"&gt;(defn timeout
"Returns a channel that will close after msecs"
[^long msecs]
(timers/timeout msecs))&lt;/pre&gt;
&lt;p&gt;I mean, nothing interesting there, just a type hint.&lt;/p&gt;
&lt;p&gt;Oh. Wait. That's not just a type hint. &lt;code class="docutils literal"&gt;long&lt;/code&gt; is a primitive.
Testing:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type (fn [^long x] x)))
#{clojure.lang.IFn$LO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;Aha! Due to a JVM quirk, functions with a primitive type hint are
special. That works for doubles, too:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type (fn [^double x] x)))
#{clojure.lang.IFn$DO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;And multiple arguments:&lt;/p&gt;
&lt;pre class="literal-block"&gt;&amp;gt; (parents (type (fn [^double x ^double y] x)))
#{clojure.lang.IFn$DDO clojure.lang.AFunction}
&amp;gt; (parents (type (fn [^double x ^long y] x)))
#{clojure.lang.IFn$DLO clojure.lang.AFunction}&lt;/pre&gt;
&lt;p&gt;Adding a simple type hint to the function fixed it. Success!&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><guid>https://www.lvh.io/posts/what-the-heck-is-a-clojurelangifnlo/</guid><pubDate>Thu, 02 Oct 2014 13:15:17 GMT</pubDate></item></channel></rss>