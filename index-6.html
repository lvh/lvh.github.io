<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="lvh's blog">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>lvh (old posts, page 6) | lvh</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#383234">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://www.lvh.io/index-6.html">
<link rel="prev" href="." type="text/html">
<link rel="next" href="index-5.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="https://www.lvh.io/">
            <img src="pinchy.svg" alt="lvh" id="logo" class="d-inline-block align-top"><span id="blog-title">lvh</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="about/" class="nav-link">About</a>
                </li>
<li class="nav-item">
<a href="archive/" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="talks/" class="nav-link">Talks</a>
                </li>
<li class="nav-item">
<a href="rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<!-- Custom search --><form method="get" id="search" action="//duckduckgo.com/" class="navbar-form pull-right">
<input type="hidden" name="sites" value="https://www.lvh.io/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="display: none;">
</form>
<!-- End of custom search -->


            <ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/cryptographic-right-answers/" class="u-url">Cryptographic right answers</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                lvh
            </span></p>
            <p class="dateline">
            <a href="posts/cryptographic-right-answers/" rel="bookmark">
            <time class="published dt-published" datetime="2018-04-03T14:25:00-07:00" itemprop="datePublished" title="2018-04-03 14:25">2018-04-03 14:25</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>We’re less interested in empowering developers and a lot more pessimistic about the prospects of getting this stuff right.</p>
<p>There are, in the literature and in the most sophisticated modern systems, “better” answers for many of these items. If you’re building for low-footprint embedded systems, you can use STROBE and a sound, modern, authenticated encryption stack entirely out of a single SHA-3-like sponge constructions. You can use NOISE to build a secure transport protocol with its own AKE. Speaking of AKEs, there are, like, 30 different password AKEs you could choose from.</p>
<p>But if you’re a developer and not a cryptography engineer, you shouldn’t do any of that. You should keep things simple and conventional and easy to analyze; “boring”, as the Google TLS people would say.</p>
<p>(This content has been developed and updated by different people over a decade. We've kept what Colin Percival originally said in 2009, Thomas Ptacek said in 2015, and what we're saying in 2018 for comparison. If you're designing something today, just use the 2018 Latacora recommendation.)</p>
<h3>Cryptographic Right Answers</h3>
<h4>Encrypting Data</h4>
<ul>
<li>
<em>Percival, 2009:</em> AES-CTR with HMAC.</li>
<li>
<em>Ptacek, 2015:</em> (1) NaCl/libsodium’s default, (2) ChaCha20-Poly1305, or (3) AES-GCM.</li>
<li>
<em>Latacora, 2018:</em> KMS or XSalsa20+Poly1305</li>
</ul>
<p><em>You care about this if:</em> you're hiding information from users or the network.</p>
<p>If you are in a position to use KMS, Amazon’s (or Google’s) Hardware Security Module time share, use KMS. If you could use KMS but encrypting is just a fun weekend project and you might be able to save some money by minimizing your KMS usage, use KMS. If you’re just encrypting secrets like API tokens for your application at startup, use SSM Parameter Store, which is KMS. You don’t have to understand how KMS works.</p>
<p>Otherwise, what you want ideally is “AEAD”: authenticated encryption with additional data (the option for plaintext authenticated headers).</p>
<p>The mainstream way to get authenticated encryption is to use a stream cipher (usually: AES in CTR mode) composed with a polynomial MAC (a cryptographic CRC).</p>
<p>The problem you’ll run into with all those mainstream options is nonces: they want you to come up with a unique (usually random) number for each stream which can never be reused. It’s simplest to generate nonces from a secure random number generator, so you want a scheme that makes that easy.</p>
<p>Nonces are particularly important for AES-GCM, which is the most popular mode of encryption. Unfortunately, it’s particularly tricky with AES-GCM, where it’s just-barely-but-maybe-not-quite on the border of safe to use random nonces.</p>
<p>So we recommend you use XSalsa20-Poly1305. This is a species of “ChaPoly” constructions, which, put together, are the most common encryption constructions outside of AES-GCM. Get XSalsa20-Poly1305 from libsodium or NaCl.</p>
<p>The advantage to XSalsa20 over ChaCha20 and Salsa20 is that XSalsa supports an extended nonce; it’s big enough that you can simply generate a big long random nonce for every stream and not worry about how many streams you’re encrypting.</p>
<p>There are “NMR” or “MRAE” schemes in the pipeline that promise some degree of security even if nonces are mishandled; these include GCM-SIV (all the SIVs, really) and CAESAR-contest-finalist Deoxys-II. They’re interesting, but nobody really supports or uses them yet, and with an extended nonce, the security win is kind of marginal. They’re not boring. Stay boring for now.</p>
<p><em>Avoid:</em> AES-CBC, AES-CTR by itself, block ciphers with 64-bit blocks --- most especially Blowfish, which is inexplicably popular, OFB mode. Don't ever use RC4, which is comically broken.</p>
<h4>Symmetric key length</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use 256-bit keys.</li>
<li>
<em>Ptacek, 2015</em>: Use 256-bit keys.</li>
<li>
<em>Latacora, 2018:</em> Go ahead and use 256 bit keys.</li>
</ul>
<p><em>You care about this if:</em> you're using cryptography.</p>
<p>But remember: your AES key is far less likely to be broken than your public key pair, so the latter key size should be larger if you're going to obsess about this.</p>
<p><em>Avoid:</em> constructions with huge keys, cipher "cascades", key sizes under 128 bits.</p>
<h4>Symmetric “Signatures”</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use HMAC.</li>
<li>
<em>Ptacek, 2015</em>: Yep, use HMAC.</li>
<li>
<em>Latacora, 2018:</em> Still HMAC.</li>
</ul>
<p><em>You care about this if:</em> you're securing an API, encrypting session cookies, or are encrypting user data but, against medical advice, not using an AEAD construction.</p>
<p>If you're authenticating but not encrypting, as with API requests, don't do anything complicated. There is a class of crypto implementation bugs that arises from how you feed data to your MAC, so, if you're designing a new system from scratch, Google "crypto canonicalization bugs". Also, use a secure compare function.</p>
<p>If you use HMAC, people will feel the need to point out that SHA3 (and the truncated SHA2 hashes) can do “KMAC”, which is to say you can just concatenate the key and data and hash them and be secure. This means that in theory HMAC is doing unnecessary extra work with SHA-3 or truncated SHA-2. But who cares? Think of HMAC as cheap insurance for your design, in case someone switches to non-truncated SHA-2.</p>
<p><em>Avoid:</em> custom "keyed hash" constructions, HMAC-MD5, HMAC-SHA1, complex polynomial MACs, encrypted hashes, CRC.</p>
<h4>Hashing algorithm</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use SHA256 (SHA-2).</li>
<li>
<em>Ptacek, 2015</em>: Use SHA-2.</li>
<li>
<em>Latacora, 2018:</em> Still SHA-2.</li>
</ul>
<p><em>You care about this if:</em> you always care about this.</p>
<p>If you can get away with it: use SHA-512/256, which truncates its output and sidesteps length extension attacks.</p>
<p>We still think it's less likely that you'll upgrade from SHA-2 to SHA-3 than it is that you'll upgrade from SHA-2 to something faster than SHA-3, and SHA-2 still looks great, so get comfortable and cuddly with SHA-2.</p>
<p><em>Avoid:</em> SHA-1, MD5, MD6.</p>
<h4>Random IDs</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use 256-bit random numbers.</li>
<li>
<em>Ptacek, 2015</em>: Use 256-bit random numbers.</li>
<li>
<em>Latacora, 2018:</em> Use 256-bit random numbers.</li>
</ul>
<p><em>You care about this if:</em> you always care about this.</p>
<p>From /dev/urandom.</p>
<p><em>Avoid:</em> userspace random number generators, the OpenSSL RNG, havaged, prngd, egd, /dev/random.</p>
<h4>Password handling</h4>
<ul>
<li>
<em>Percival, 2009</em>: scrypt or PBKDF2.</li>
<li>
<em>Ptacek, 2015</em>:  In order of preference, use scrypt, bcrypt, and then if nothing else is available PBKDF2.</li>
<li>
<em>Latacora, 2018:</em>  In order of preference, use scrypt, argon2, bcrypt, and then if nothing else is available PBKDF2.</li>
</ul>
<p><em>You care about this if:</em> you accept passwords from users or, anywhere in your system, have human-intelligible secret keys.</p>
<p>But, seriously: you can throw a dart at a wall to pick one of these. Technically, argon2 and scrypt are materially better than bcrypt, which is much better than PBKDF2. In practice, it mostly matters that you use a real secure password hash, and not as much which one you use.</p>
<p>Don’t build elaborate password-hash-agility schemes.</p>
<p><em>Avoid:</em> SHA-3, naked SHA-2, SHA-1, MD5.</p>
<h4>Asymmetric encryption</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use RSAES-OAEP with SHA256 and MGF1+SHA256 bzzrt pop ffssssssst exponent 65537.</li>
<li>
<em>Ptacek, 2015</em>: Use NaCl/libsodium (box / crypto_box).</li>
<li>
<em>Latacora, 2018:</em>  Use Nacl/libsodium (box / crypto_box).</li>
</ul>
<p><em>You care about this if</em>: you need to encrypt the same kind of message to many different people, some of them strangers, and they need to be able to accept the message asynchronously, like it was store-and-forward email, and then decrypt it offline. It's a pretty narrow use case.</p>
<p>Of all the cryptographic "right answers", this is the one you're least likely to get right on your own. Don't freelance public key encryption, and don't use a low-level crypto library like OpenSSL or BouncyCastle.</p>
<p>Here are several reasons you should stop using RSA and switch to elliptic curve:</p>
<ul>
<li>RSA (and DH) drag you towards "backwards compatibility" (ie: downgrade-attack compatibility) with insecure systems.</li>
<li>RSA begs implementors to encrypt directly with its public key primitive, which is usually not what you want to do</li>
<li>RSA has too many knobs. In modern curve systems, like Curve25519, everything is pre-set for security.</li>
</ul>
<p>NaCl uses Curve25519 (the most popular modern curve, carefully designed to eliminate several classes of attacks against the NIST standard curves) in conjunction with a ChaPoly AEAD scheme. Your language will have bindings (or, in the case of Go, its own library implementation) to NaCl/libsodium; use them. Don’t try to assemble this yourself. Libsodium has <a href="https://libsodium.gitbook.io/doc/bindings_for_other_languages">a list</a>.</p>
<p>Don't use RSA.</p>
<p><em>Avoid:</em> Systems designed after 2015 that use RSA, RSA-PKCS1v15, RSA, ElGamal, I don't know, Merkle-Hellman knapsacks? Just avoid RSA.</p>
<h4>Asymmetric signatures</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use RSASSA-PSS with SHA256 then MGF1+SHA256 in tricolor systemic silicate orientation.</li>
<li>
<em>Ptacek, 2015</em>: Use Nacl, Ed25519, or RFC6979.</li>
<li>
<em>Latacora, 2018:</em>  Use Nacl or Ed25519.</li>
</ul>
<p><em>You care about this if</em>: you're designing a new cryptocurrency. Or, a system to sign Ruby Gems or Vagrant images, or a DRM scheme, where the authenticity of a series of files arriving at random times needs to be checked offline against the same secret key. Or, you're designing an encrypted message transport.</p>
<p>The allegations from the previous answer are incorporated herein as if stated in full.</p>
<p>The two dominating use cases within the last 10 years for asymmetric signatures are cryptocurrencies and forward-secret key agreement, as with ECDHE-TLS. The dominating algorithms for these use cases are all elliptic-curve based. Be wary of new systems that use RSA signatures.</p>
<p>In the last few years there has been a major shift away from conventional DSA signatures and towards misuse-resistent "deterministic" signature schemes, of which EdDSA and RFC6979 are the best examples. You can think of these schemes as "user-proofed" responses to the Playstation 3 ECDSA flaw, in which reuse of a random number leaked secret keys. Use deterministic signatures in preference to any other signature scheme.</p>
<p>Ed25519, the NaCl/libsodium default, is by far the most popular public key signature scheme outside of Bitcoin. It’s misuse-resistant and carefully designed in other ways as well. You shouldn’t freelance this either; get it from NaCl.</p>
<p><em>Avoid:</em> RSA-PKCS1v15, RSA, ECDSA, DSA; really, especially avoid conventional DSA and ECDSA.</p>
<h4>Diffie-Hellman</h4>
<ul>
<li>
<em>Percival, 2009</em>: Operate over the 2048-bit Group #14 with a generator of 2.</li>
<li>
<em>Ptacek, 2015</em>: Probably still DH-2048, or Nacl.</li>
<li>
<em>Latacora, 2018:</em>  Probably nothing. Or use Curve25519.</li>
</ul>
<p><em>You care about this if:</em> you're designing an encrypted transport or messaging system that will be used someday by a stranger, and so static AES keys won't work.</p>
<p>The 2015 version of this document confused the hell out of everyone.</p>
<p>Part of the problem is that our “Right Answers” are a response to Colin Percival’s “Right Answers”, and his included a “Diffie-Hellman” answer, as if “Diffie-Hellmanning” was a thing developers routinely do. In reality, developers simply shouldn’t freelance their own encrypted transports. To get a sense of the complexity of this issue, read the documentation for the Noise Protocol Framework. If you’re doing a key-exchange with DH, you probably want an authenticated key exchange (AKE) that resists key compromise impersonation (KCI), and so the primitive you use for DH is not the only important security concern.</p>
<p>But whatever.</p>
<p>It remains the case: if you can just use NaCl, use NaCl. You don't even have to care what NaCl does. That’s the point of NaCl.</p>
<p>Otherwise: use Curve25519. There are libraries for virtually every language. In 2015, we were worried about encouraging people to write their own Curve25519 libraries, with visions of Javascript bignum implementations dancing in our heads. But really, part of the point of Curve25519 is that the entire curve was carefully chosen to minimize implementation errors. Don’t write your own! But really, just use Curve25519.</p>
<p>Don’t do ECDH with the NIST curves, where you’ll have to carefully verify elliptic curve points before computing with them to avoid leaking secrets. That attack is very simple to implement, easier than a CBC padding oracle, and far more devastating.</p>
<p>The 2015 document included a clause about using DH-1024 in preference to sketchy curve libraries. You know what? That’s still a valid point. Valid and stupid. The way to solve the “DH-1024 vs. sketchy curve library” problem is, the same as the “should I use Blowfish or IDEA?” problem. Don’t have that problem. Use Curve25519.</p>
<p><em>Avoid:</em> conventional DH, SRP, J-PAKE, handshakes and negotiation, elaborate key negotiation schemes that only use block ciphers, srand(time()).*</p>
<h4>Website security</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use OpenSSL.</li>
<li>
<em>Ptacek, 2015</em>: Remains: OpenSSL, or BoringSSL if you can. Or just use AWS ELBs</li>
<li>
<em>Latacora, 2018:</em>  Use AWS ALB/ELB or OpenSSL, with LetsEncrypt</li>
</ul>
<p><em>You care about this if:</em> you have a website.</p>
<p>If you can pay AWS not to care about this problem, we recommend you do that.</p>
<p>Otherwise, there was a dark period between 2010 and 2016 where OpenSSL might not have been the right answer, but that time has passed. OpenSSL has gotten better, and, more importantly, OpenSSL is on-the-ball with vulnerability disclosure and response.</p>
<p>Using anything besides OpenSSL will drastically complicate your system for little, no, or even negative security benefit. So just keep it simple.</p>
<p>Speaking of simple: LetsEncrypt is free and automated. Set up a cron job to re-fetch certificates regularly, and test it.</p>
<p><em>Avoid:</em> offbeat TLS libraries like PolarSSL, GnuTLS, and MatrixSSL.</p>
<h4>Client-server application security</h4>
<ul>
<li>
<em>Percival, 2009</em>: Distribute the server's public RSA key with the client code, and do not use SSL.</li>
<li>
<em>Ptacek, 2015</em>: Use OpenSSL, or BoringSSL if you can. Or just use AWS ELBs</li>
<li>
<em>Latacora, 2018:</em>  Use AWS ALB/ELB or OpenSSL, with LetsEncrypt</li>
</ul>
<p><em>You care about this if:</em> the previous recommendations about public-key crypto were relevant to you.*</p>
<p>It seems a little crazy to recommend TLS given its recent history:</p>
<ul>
<li>The Logjam DH negotiation attack</li>
<li>The FREAK export cipher attack</li>
<li>The POODLE CBC oracle attack</li>
<li>The RC4 fiasco</li>
<li>The CRIME compression attack</li>
<li>The Lucky13 CBC padding oracle timing attack</li>
<li>The BEAST CBC chained IV attack</li>
<li>Heartbleed</li>
<li>Renegotiation</li>
<li>Triple Handshakes</li>
<li>Compromised CAs</li>
<li>DROWN (though personally we’re warped and an opportunity to play with attacks like DROWN would be in our “pro” column)</li>
</ul>
<p>Here's why you should still use TLS for your custom transport problem:</p>
<ul>
<li>In custom protocols, you don’t have to (and shouldn’t) depend on 3rd party CAs. You don’t even have to use CAs at all (though it’s not hard to set up your own); you can just use a whitelist of self-signed certificates  which is approximately what SSH does by default, and what you’d come up with on your own.</li>
<li>Since you’re doing a custom protocol, you can use the best possible TLS cipher suites: TLS 1.2+, Curve25519, and ChaPoly. That eliminates most attacks on TLS. The reason everyone doesn’t do this is that they need backwards-compatibility, but in custom protocols you don’t need that.</li>
<li>Many of these attacks only work against browsers, because they rely on the victim accepting and executing attacker-controlled Javascript in order to generate repeated known/chosen plaintexts.</li>
</ul>
<p><em>Avoid:</em> designing your own encrypted transport, which is a genuinely hard engineering problem; using TLS but in a default configuration, like, with "curl"; using "curl", IPSEC.</p>
<h4>Online backups</h4>
<ul>
<li>
<em>Percival, 2009</em>: Use Tarsnap.</li>
<li>
<em>Ptacek, 2015</em>: Use Tarsnap.</li>
<li>
<em>Latacora, 2018:</em>  Store PMAC-SIV-encrypted arc files to S3 and save fingerprints of your backups to an ERC20-compatible blockchain.</li>
</ul>
<p><em>You care about this if:</em> you bother backing things up.</p>
<p>Just kidding. You should still use Tarsnap.</p>
<p>(This post was syndicated on the Latacora blog.)</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/smaller-clojure-docker-builds-with-multi-stage-builds/" class="u-url">Smaller Clojure Docker builds with multi-stage builds</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                lvh
            </span></p>
            <p class="dateline">
            <a href="posts/smaller-clojure-docker-builds-with-multi-stage-builds/" rel="bookmark">
            <time class="published dt-published" datetime="2017-06-16T10:12:46-07:00" itemprop="datePublished" title="2017-06-16 10:12">2017-06-16 10:12</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>A common pattern in Docker is to use a separate build environment from the
runtime environment. Many platforms have different requirements when you're
generating a runnable artifact than when you're running it.</p>
<p>In languages like Go, Rust or C, where the most common implementations produce
native binaries, the resulting artifact may require nothing from the environment
at all, or perhaps as little as a C standard library. Even in languages like
Python that don't typically have a build step, you might indirectly use code
that still requires compilation. Common examples include OpenSSL with
pyca/cryptography or NETLIB and other numerical libraries with numpy/scipy.</p>
<p>In Clojure, you can easily build "uberjars" with both lein and boot. These are
jars (the standard JVM deployable artifact) that come with all dependencies
prepackaged, requiring nothing beyond what's in the Java standard library
(rt.jar). While this still requires a JRE to run, that is still much smaller
than the full development environment.</p>
<p>There are a few advantages to separating environments. It all boils down to them
not having anything in them they don't need. That has clear performance
advantages, although Docker has historically mitigated this problem with layered
pulls. It can have security benefits as well: you can't have bugs in software
you don't ship. Even software that isn't directly used in the build process can
be affected: some build environments will contain plenty of software that is
never used that would normally carry over into your production environments.</p>
<p>Historically, most users of Docker haven't bothered. Even if there are
advantages, they aren't worth the hassle of having separate Docker environments
and ferrying data between them. While different ways of effectively sharing data
between containers have been available for years, people who wanted a shared
build step have mostly had to write their own tooling. For example,
my <a href="https://github.com/lvh/icecap/blob/master/utils/build-libsodium-package.sh">icecap</a> project has a batch file with an embedded Dockerfile that builds
libsodium debs.</p>
<p>The upcoming release of Docker will add support for a new feature called
multi-stage builds, where this pattern is much simpler. Dockerfiles themselves
know about your precursor environments now, and future containers have full
access to previous containers for copying build artifacts around. This
requires Docker 17.05 or newer.</p>
<p>Here's an example Dockerfile that builds an uberjar from a standard lein-based
app, and puts it in a new JRE image:</p>
<pre class="code literal-block"><span></span>FROM clojure AS build-env
WORKDIR /usr/src/myapp
COPY project.clj /usr/src/myapp/
RUN lein deps
COPY . /usr/src/myapp
RUN mv "$(lein uberjar | sed -n 's/^Created \(.*standalone\.jar\)/\1/p')" myapp-standalone.jar

FROM openjdk:8-jre-alpine
WORKDIR /myapp
COPY --from=build-env /usr/src/myapp/myapp-standalone.jar /myapp/myapp.jar
ENTRYPOINT ["java", "-jar", "/myapp/myapp.jar"]
</pre>


<p>This captures the uberjar name from the <code>lein uberjar</code> output. If your uberjar
name doesn't end in <code>.standalone.jar</code>, that won't work. You can change the name
of the uberjar with the <code>:uberjar-name</code> setting in <code>project.clj</code>. If you set it
to <code>myapp-standalone.jar</code>, you don't need the gnarly <code>sed</code> expression anymore at
all, and can just call <code>lein uberjar</code>. (Thanks to Łukasz Korecki for the
suggestion!)</p>
<p>The full clojure base image is a whopping 629MB (according to <code>docker images</code>),
whereas <code>openjdk:8-jre-alpine</code> clocks in at 81.4MB. That's a little bit of an
unfair comparison: <code>clojure</code> also has an alpine-based image. However, this still
illustrates the savings compared to the most commonly used Docker image.</p>
<p>There are still good reasons for not using multi-stage builds. In the icecap
example above, the entire point is to use Docker as a build system to produce
a deb artifact <em>outside of Docker</em>. However, that's a pretty exotic use case:
for most people this will hopefully make smaller Docker images an easy
reality.</p>
<p><em>Edited:</em> The original blog post said that the Docker version to support this
feature was in beta at time of writing. That was/is correct, but it's since
been released, so I updated the post.</p>
<p><em>Edited:</em>* Łukasz Korecki pointed out that <code>project.clj</code> has an <code>:uberjar-name</code>
parameter which can be used to avoid the gnarly <code>sed</code> expression. Thanks Łukasz!</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016-rmbp-caveats/" class="u-url">2016 rMBP caveats</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                lvh
            </span></p>
            <p class="dateline">
            <a href="posts/2016-rmbp-caveats/" rel="bookmark">
            <time class="published dt-published" datetime="2016-11-22T07:49:16-08:00" itemprop="datePublished" title="2016-11-22 07:49">2016-11-22 07:49</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>I bought the 2016 15" retina MacBook Pro as soon as it became available. I've
had it for a week now, and there have been some issues you might want to be
aware of if you'd like to get one.</p>
<p>(There are a bunch of links to Amazon in this article. They're not affiliate
links.)</p>
<h2>System Integrity Protection is often disabled</h2>
<p>I noticed <a href="https://twitter.com/schwa/status/799160866209828864">via Twitter</a> that some people were reporting that <a href="https://en.wikipedia.org/wiki/System_Integrity_Protection">System Integrity
Protection (SIP)</a> was disabled by default on their Macs. SIP is a mechanism via
which macOS protects critical system files from being overwritten.</p>
<p>You can check if SIP is enabled on your system by running <code>csrutil status</code> in a
terminal. Sure enough, SIP was disabled for both me and my wife's new rMBPs. To
enable SIP, boot into the recovery mode (hold ⌘-R when booting), open a
terminal, type <code>csrutil enable</code> and reboot.</p>
<p>Perhaps unrelatedly, different out-of-the-box rMBPs appear to have different
builds of OS X Sierra 10.12.1.</p>
<h2>Thunderbolt 2 dongle doesn't work with external screens</h2>
<p>I have a Dell 27" 4k montior (P2715Q). I used it with my previous-generation
rMBP with a DisplayPort-to-mDP2 cable to connect it to its Thunderbolt 2 port.
When buying my laptop, it suggested I get a Thunderbolt 3 to Thunderbolt 2
dongle. I was expecting to get a Thunderbolt 2 port like the one on my previous
Mac. When I plugged it in to my monitor, it told me that there was a cable
plugged in, but no signal coming from the computer.</p>
<p>My understanding was that the Thunderbolt spec implies PCIe lanes and other
protocols over the same port. Specifically, Thunderbolt 2 means 4 PCI Express
2.0 lanes with DisplayPort 1.2; at a cursory glance, <a href="https://en.wikipedia.org/wiki/Thunderbolt_(interface)">Wikipedia agrees</a>.
(Thunderbolt 3 adds HDMI 2.0 and USB 3.1 gen 2.)</p>
<p>I spent about an hour and a half on the phone with AppleCare folks. The Apple
support people were very friendly. (I'm guessing their instructions tell them to
never, under any circumstances, interrupt a customer. It was a little weird.) I
was redirected a few times. They had a variety of suggestions, including:</p>
<ul>
<li>Changing my monitor to MST mode, which shouldn't be necessary for DisplayPort
  1.2-supporting devices, and did nothing but make my monitor not work with my old
  rMBP either. Fortunately I was able to recover via HDMI to my old laptop.</li>
<li>Buying the Apple Digital AV Adapter instead. That adapter used HDMI instead of
  mDP2. That's a significant downgrade; my use of DisplayPort was intentional,
  because DisplayPort 1.2 is the only way I can power the 4K display at 60Hz.
  (The new adapter does not support HDMI 2.0, which is necessary for 4K@60Hz.)</li>
<li>Buying a third-party DisplayPort adapter or dock. This is precarious at best.
  Most existing devices <a href="https://9to5mac.com/2016/11/03/2016-macbook-pro-thunderbolt-compatibility-issues/">don't work with the new rMBP</a>, because they
  use a previous-generation TI chip. There are plenty of docks that wont work,
  by <a href="https://www.amazon.com/StarTech-com-Thunderbolt-Dual-4K-Docking-Station">StarTech</a>, <a href="https://www.amazon.com/Dell-Dock-WD15-Adapter-Type-C">Dell</a>, <a href="https://www.amazon.com/Kensington-Delivery-DisplayPort-Microphone-K38231WW">Kensington</a>
  and <a href="https://www.amazon.com/Plugable-Display-Docking-Charging-Delivery">Plugable</a>. I found one Dock by <a href="https://www.amazon.com/CalDigit-USB-C-Docking-Station-DisplayPort">CalDigit</a> that will
  ostensibly work with the new rMBP, but doesn't supply enough power to charge
  it.</li>
</ul>
<p>Eventually, we found <a href="https://support.apple.com/en-us/HT207266">a KB article</a> that spells out that the Thunderbolt
dongle doesn't work for DisplayPort displays:</p>
<blockquote>
<p>The Thunderbolt 3 (USB-C) to Thunderbolt 2 Adapter doesn't support connections to these devices:</p>
<ul>
<li>Apple DisplayPort display</li>
<li>DisplayPort devices or accessories, such as Mini DisplayPort to HDMI or Mini DisplayPort to VGA adapters</li>
<li>4K Mini DisplayPort displays that don’t have Thunderbolt</li>
</ul>
</blockquote>
<p>I'm a little vindicated by the <a href="http://www.apple.com/shop/reviews/MMEL2AM/A/thunderbolt-3-usb-c-to-thunderbolt-2-adapter">Mac Store</a> review page for the dongle;
apparently I wasn't the only person to expect that. (I was unable to see the
reviews before my purchase, because I purchased it with my Mac, which doesn't
show reviews. Also, the product was brand new at the time, and didn't have these
reviews yet.)</p>
<p><a href="http://www.belkin.com/us/p/P-F4U095/">Belkin</a> and <a href="https://9to5mac.com/2016/11/03/owc-announces-thunderbolt-3-dock-adds-13-ports-of-legacy-io-to-the-new-macbook-pros-over-a-single-cable/">OWC</a> will be shipping docks that allegedly work with
the new rMBP, but Belkin's is currently unavailable with no ship date mentioned,
and OWC claims February 2017.</p>
<h2>WiFi failing with USB-C devices plugged in</h2>
<p>Just as I was going to start writing this post, I noticed that I wasn't able
to sync my blog repository from GitHub:</p>
<pre class="code literal-block"><span></span>Get https://api.github.com/repos/lvh/lvh.github.io: dial tcp 192.30.253.116:443: connect: network is unreachable
</pre>


<p>It didn't click at first what was going on. I restarted my router, connected to
different networks, tried a different machine -- all telling me it was this
laptop that was misbehaving. I started trying everything, and realized I had
recently plugged in my WD backup drive from which I was copying over an SSH key.
It's a USB 3.0 drive that I'm connecting via an AUKEY USB 3 to USB-C converter.
I removed the drive, and my WiFi starts working again. Plugging it back in does
not instantly, but eventually, break WiFi again.</p>
<p>After searching, I was able <a href="https://www.youtube.com/watch?v=NYVjIjBMx6o">to find someone with the same problem</a>.
It is unclear to me if this issue is related to the first-gen TI chip issue
mentioned above. In that video, the authors are also using a USB 3.0 to USB-C
plug, albeit a different one from mine. I don't have a reference USB-C machine
that isn't a new 2016 rMBP to test with. However, this seems plausible, because
the USB 3.0 dongle I purchased from Apple ostensibly works fine.</p>
<p>This does not seem like a reasonable failure mode.</p>
<h2>The escape key, and the new keyboard</h2>
<p>I spend most of my day in Emacs. I'm perfectly happy with the new keyboard. I've
also used the regular MacBook butterfly keyboard, and the new version is
significantly better. I've never had a problem with not having an escape key;
every app where I would've cared to press it had an escape key drawn on the new
Touch Bar. However, not having tactile feedback for the escape key is annoying.
When I was setting up my box and quickly editing a file in vim, I successfully
pressed Escape to exit insert mode -- but I ended up pressing it five times
because I thought I didn't hit it. Apparently the visual feedback vim gives me
that I've exited insert mode is not, actually, what my brain relies on. I'll let
you know if I get used to it.</p>
<h2>Charging</h2>
<p>I'll miss the safety of Magsafe, but being able to plug in your charger on
either side is an unexpected nice benefit.</p>
<h2>Conclusion</h2>
<p>I was ready to accept a transition period of dongles; I bought into it,
literally and figuratively. However, most of the dongles don't actually work,
and that sucks. So, maybe wait for the refresh, or at least until the
high-quality docks are available.</p>
</div>
    </div>
    </article>
</div>

        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="." rel="prev">Newer posts</a></li>
            <li class="next"><a href="index-5.html" rel="next">Older posts</a></li>
        </ul>
<!--End of body content--><footer id="footer">
            Contents © 2019         <a href="mailto:_@lvh.io">lvh</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-36779422-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
