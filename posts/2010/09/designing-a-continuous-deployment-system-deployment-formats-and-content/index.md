<!--
.. title: Designing a continuous deployment system: deployment formats and content
.. date: 2010/09/30 13:37
.. slug: designing-a-continuous-deployment-system-deployment-formats-and-content
.. link:
.. description:
.. tags: 
-->

<div>Hi and welcome again to my articles on continuous deployment! In this article, I&#39;m going to talk about <i>what</i> exactly I think you should deploy and what format you should use to deploy it in.</div><p /> <div>Again, the stuff here probably isn&#39;t super controversial. I&#39;m probably not kicking any shins in this one unless you&#39;ve already done continuous deployment and you picked something else. Analogous with the last article, if you don&#39;t really care about deployment formats, save yourself the time and don&#39;t bother reading.</div> <p /><div>When getting in touch with a few people I know are doing continuous deployment, there are a number of things I&#39;ve heard people say about formats and what exactly to deploy. Here&#39;s what they used:</div> <div><ol><li>Distribution packages (debs, rpms...)</li><li>Language&#39;s native packages (eggs, gems, ...)</li><li>The development environment</li><li>The test environment</li></ol></div><div>(Although it appears that this list confounds two things (formats and content); that&#39;s not entirely true. These packages are generated using standard practice packaging rules with standard content, almost as if they were part of a distribution/PyPI/Rubyforge...)</div> <p /><div>Some people have reported success deploying native packages. It definitely has it&#39;s advantages in terms of accounting, plus you get to use all of the tools already available for managing package installation on large networks. (As a practical example: PPAs and apt repositories in general, together with Landscape or other tools for managing updates for Ubuntu servers.) Hence, the choice for native packages is understandable: in big existing companies, using existing infrastructure is a big plus.</div> <p /><div>When greenfielding, however, I would prefer to avoid both distribution packages and native packages. One problem is that pretty much all of these are designed for system-wide installations. There are methods of getting around this, such as Python&#39;s virtualenvs, but that makes the system specific to a particular language and set of deployment tools, and I&#39;ve already argued in a previous post why I&#39;d rather avoid that unless there really is no better option.<span style="font-family: arial, helvetica, sans-serif;"> Since nowhere near every reasonable development platform has such a sandboxing tool, it&#39;s not possible to form an abstraction over it.</span></div> <p /><div>A related problem is that it&#39;s generally impossible to reliably install multiple versions of these concurrently in a widely supported way (again,with the exception of language-specific tricks like virtualenvs). That&#39;s not necessarily a huge problem, but it does make reverting to an older version slightly harder. That might not seem like a big deal, but easy reverts are a big part of cautious deployment (more about that in the next installment). Additionally, there&#39;s nothing to prevent a bad/broken package from having side effects that break older installs as well -- as usual, shared mutable state is asking for trouble.</div> <p /><div>Another thing I&#39;ve seen people package is their development environment. Unless you&#39;re also using this as the base for your tests, I think this is a very bad idea. I think we&#39;ve all had cases where something worked fine on a development box, and started breaking for new checkouts. During development, all sorts of stuff Some languages/development environments are more susceptible to these problems than others, but they&#39;re prevalent enough to want to avoid the problem altogether.</div> <p /><div>Even if you are testing your development environment, I dislike it for purity reasons. The people doing this said they did that because it was the easiest way to get stuff running, and they just went along with the path of least resistance. As much as I&#39;m willing to believe that&#39;s true, I also believe that if you need a developer to chant some magic runes and sacrifice a chicken over a checkout of your code before it&#39;ll actually work, you&#39;re doing it wrong.</div> <p />I think repackaging test environments for deployment is a sensible idea. I talked this over with Holger Krekel, the guy who wrote <a href="http://codespeak.net/tox/" target="_blank">Tox</a>, and he immediately pointed out a flaw in that plan: it&#39;ll only work reliably if the testing environment is identical to the deployment environment in terms of platform, architecture, versions of available software... I thought this was a limitation at first, but I&#39;m now convinced this is a useful limitation (another idea I stole from Holger ;)). If you didn&#39;t <i>test</i> it in environment X, what business do you have <i>deploying</i> it there? <p /><div>I think I&#39;ve got most of the annoying administrative stuff out of the way now, maybe we can move on to more interesting things that are actually specific to continuous deployment :-) That starts with the next article, which, as I&#39;ve already hinted above, will be about &quot;cautious deployment&quot;, a robust technique for scheduling deployment.</div>
