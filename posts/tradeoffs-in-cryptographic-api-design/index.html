<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Tradeoffs in cryptographic API design | lvh</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#383234">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://www.lvh.io/posts/tradeoffs-in-cryptographic-api-design/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="lvh">
<link rel="prev" href="../nonce-misuse-resistance-101/" title="Nonce misuse resistance 101" type="text/html">
<link rel="next" href="../crypto-apis-and-jvm-byte-types/" title="Crypto APIs and JVM byte types" type="text/html">
<meta property="og:site_name" content="lvh">
<meta property="og:title" content="Tradeoffs in cryptographic API design">
<meta property="og:url" content="https://www.lvh.io/posts/tradeoffs-in-cryptographic-api-design/">
<meta property="og:description" content="Producing cryptographic software is a difficult and specialized endeavor. One
of the pitfalls is that getting it wrong looks exactly like getting it
right. Much like a latent memory corruption bug or ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-06-18T13:45:35-07:00">
<meta property="article:tag" content="cryptography">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="https://www.lvh.io/">
            <img src="../../pinchy.svg" alt="lvh" id="logo" class="d-inline-block align-top"><span id="blog-title">lvh</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../about/" class="nav-link">About</a>
                </li>
<li class="nav-item">
<a href="../../archive/" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../talks/" class="nav-link">Talks</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<!-- Custom search --><form method="get" id="search" action="//duckduckgo.com/" class="navbar-form pull-right">
<input type="hidden" name="sites" value="https://www.lvh.io/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="display: none;">
</form>
<!-- End of custom search -->


            <ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Tradeoffs in cryptographic API design</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    lvh
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2016-06-18T13:45:35-07:00" itemprop="datePublished" title="2016-06-18 13:45">2016-06-18 13:45</time></a>
            </p>
            
        <p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>Producing cryptographic software is a difficult and specialized endeavor. One
of the pitfalls is that getting it wrong looks exactly like getting it
right. Much like a latent memory corruption bug or a broken distributed
consensus algorithm, a piece of cryptographic software can appear to be
functioning perfectly, while being subtly broken in a way that only comes to
light years later. As the adage goes, attacks never get worse; they only get
better. Implementation concerns like timing attacks can be fiendishly
complicated to solve, involving problems like division instructions on modern
Intel CPUs taking a variable number of cycles depending on the size of the
input. Implementation concerns aren't the only problem; just designing the
APIs themselves is a complex task as well.</p>
<p>Like all API design, cryptographic API design is a user experience
exercise. It doesn't matter how strong or fast your cryptographic software is
if no one uses it. The people who end up with ECB mode didn't end up with it
because they understood what that meant. They got stuck with it because it was
the default and it didn't require thinking about scary parameters like IVs,
nonces, salts and tweaks. Even if someone ended up with CTR or CBC, these APIs
are still precarious; they'll still be vulnerable to issues like nonce
reuse, fixed IV, key-as-IV, unauthenticated encryption...</p>
<p>User experience design always means deep consideration of who your users
are. A particular API might be necessary for a cryptographic engineer to build
new protocols, but that API is probably not a reasonable default encryption
API. An explicit-nonce encryption scheme is great for a record layer protocol
between two peers like TLS, but it's awful for someone trying to encrypt a
session cookie. We can't keep complaining about people getting it wrong when
we keep giving them no chances at getting it right. This is why I'm building
educational material like <a href="https://www.crypto101.io/">Crypto 101</a> and why I care about
cryptography like <a href="../nonce-misuse-resistance-101.html">nonce-misuse resistance</a> that's easier to use
correctly.  (The blog post on my new nonce-misuse resistant schemes for
libsodium is coming soon, I promise!)</p>
<p>Before you can make your API easy to use, first you have to worry about
getting it to work at all.</p>
<p>An underlying cryptographic library might expose an unfortunate API. It might
be unwieldy because of historical reasons, backwards compatibility, language
limitations, or even simple oversight. Regardless of why the API is the way it
is, even minute changes to it—a nicer type, an implied parameter—might have
subtle but catastrophic consequences for the security of the final
product. Figuring out if an arbitrary-length integer in your programming
language is interchangeable with other representations, like the
implementation in your crypto library or a <code>char *</code>, has many complex
facets. It doesn't just have to be true under some conditions; ideally, it's
true for every platform your users will run your software on, in perpetuity.</p>
<p>There might be an easy workaround to an annoying API. C APIs often take a
<code>char *</code> together with a length parameter, because C doesn't have a standard
way of passing a byte sequence together with its length. Most higher level
languages, including Java and Python, have byte sequence types that know their
own length. Therefore, you can specify the <code>char *</code> and its associated length
in a single parameter on the high-level side. That's just the moral equivalent
of building a small C struct that holds both. (Whether or not you can trust C
compilers to get anything right at all is a point of contention.)</p>
<p>These problems compound when you are binding libraries in languages and
environments with wildly different semantics. For example, your runtime might
have a relocating garbage collector.  Pointers in C and objects in CPython
stay put, but objects move around all the time in environments like the JVM
(HotSpot) or PyPy. That implies copying to or from a buffer whenever you call
C code, unless the underlying virtual machine supports "memory pinning":
forcing the object to stay put for the duration of the call.</p>
<p>Programmers normally operate in a drastically simplified model of the
world. We praise programming designs for their ability to separate concerns,
so that programmers can deal with one problem at a time. The modern CPU your
code runs on is always an intricate beast, but you don't worry about cache
lines when you're writing a Python program. Only a fraction of programmers
ever has to worry about them at all. Those that do typically only do so after
the program already works so they can still focus on one part of the problem.</p>
<p>When designing cryptographic software, these simplified models we normally
program in don't generally work.  A cryptographic engineer often needs to
worry about concerns all the way up and down the stack simultaneously: from
application layer concerns, to runtime semantics like the
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">Java Language Specification</a>, to FFI semantics and the C ABI on all
relevant platforms, to the underlying CPU, to the mathematical underpinnings
themselves. The engineer has to manage all of those, often while being
hamstrung by flawed designs like TLS' MAC-then-pad-then-encrypt mess.</p>
<p>In future blog posts, I'll go into more detail about particular cryptographic
API design concerns, starting with JVM byte types. If you're interested, you
should <a href="https://twitter.com/lvh">follow me on Twitter</a> or <a href="../../rss.xml">subscribe to my blog's feed</a>.</p>
<p><em>Footnote:</em> I'm happy to note that <a href="https://bitbucket.org/cffi/cffi/commits/61e03368485cb78471f701adbfd1bde69a6eaa31">cffi</a> now also has
support for memory pinning since PyPy will support it in the upcoming
5.2 release, although that means I'll no longer be able to make
<a href="https://github.com/reaperhulk">Paul Kehrer of PyCA fame</a> jealous with the pinning support in
<a href="https://github.com/lvh/caesium">caesium</a>.</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../tags/cryptography/" rel="tag">cryptography</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../nonce-misuse-resistance-101/" rel="prev" title="Nonce misuse resistance 101">Previous post</a>
            </li>
            <li class="next">
                <a href="../crypto-apis-and-jvm-byte-types/" rel="next" title="Crypto APIs and JVM byte types">Next post</a>
            </li>
        </ul></nav></aside></article><!--End of body content--><footer id="footer">
            Contents © 2019         <a href="mailto:_@lvh.io">lvh</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-36779422-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
