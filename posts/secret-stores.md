<!--
.. title: Secret stores
.. slug: secret-stores
.. date: 2017-01-18 13:15:16 UTC-08:00
.. tags: private, security, crypto
.. category:
.. link:
.. description:
.. type: text
-->

Applications need secrets. TLS certificates, credentials for your database or
cloud provider: there are plenty of things your application may need access to
that you don't want anyone else to have access to.

Most companies don't have a particularly comprehensive strategy for managing
secrets. They're often committed to version control, kept on one person's
machine, accidentally leaked via environment variables, et cetera. Sometimes
secrets get added to build artifacts like Docker images. There's rarely any kind
of comprehensive story for key rotation or audit logs. Most sets of secrets
don't have the principle of least authority applied to them; applications get
access secrets by default, not by exception, and there's no mechanism in place
for limiting that.

These practices are generally understood to be awful, and there are a lot of
homegrown mechanisms for improving this. For example, the credentials in source
control might be encrypted; moving the trusted actors from "everyone with the
source code" to "the one trusted deployment machine".

This post is not about password managers. Password managers have many similar
design constraints, but are still fundamentally different beasts with completely
different users. Secret stores (as defined in this post) are consumed by
computers. The secrets are often generated by a third party, and are normally
very high entropy (a human wouldn't be able to remember them). By comparison, a
password manager is used by humans, accessed with a relatively low entropy
passphrase, and is often responsible for generating the secrets to begin with.
This post is also not about cold storage, like the physical vault where you keep
your AWS master password.

This post is intended to be an overview of how we can do better. First, I'll
argue that we can do better at all. If you're already convinced secret stores
are a great idea, you can jump ahead to the [contenders](#contenders).

# Chicken versus egg

At first sight, secret stores might sound like a fool's errand. Clearly, access
to secrets is a sensitive operation that you want to properly authenticate.
Machines authenticate themselves to other machines with high entropy secrets.
So, you still need to give the machine a secret anyway; and it seems like all
you've done is kick the can down the road a little.

There are plenty of useful features a secret store might get you:

* It knows how to encrypt and store secrets securely. Having one specialized
  application have an opinion on how to do that is much better than having a
  hundred ones that do it incidentally. The central one will be audited and
  monitored. The hundreds will invariably mess it up. As the old adage goes:
  defenders have to be right all the time, attackers only have to be right once.

* It tracks who accessed a secret and when. This is critical information for
  remediation and ongoing scope reduction. Knowing who accessed what and when
  probably gives you the context for why; all three tell you how to further
  reduce the authority that application has, or reconstruct a detailed audit
  trail.

* It can generate "minimal" credentials on-demand. Minimal means you get a key
  that only lets you access what you need and for a limited amount of time. For
  example, if you need to access specific AWS resources, you'd only be able to
  access those. On-demand means that they key can be created when you ask for
  it, and isn't shared with anyone else. (This is something dear to my heart;
  while [icecap][icecap] is anything but production software, it's essentially
  this idea turned up to eleven.)

* It can encrypt things on behalf of the requester, such that the requester
  never sees the key. That is good, because it can be one-way. It is also good
  because if a service is compromised, the compromise may be detected and
  remediated (access revoked) before all data is dumped and compromised. Having
  the secret store lets you do e.g. rate limiting and centralized monitoring,
  for example.

* Secret stores can know how secrets are linked; making it easier to do
  revocation, and easier to determine the impact of a breach or misuse incident.

* Once secrets are managed in a centralized place, it becomes feasible to have a
  coherent rotation strategy.

This concept is important to consider, because some schemes do not have these
features, and hence the rationale applies.

# Bootstrapping

This problem of needing some identity or secret to start from is called
*bootstrapping*. One traditional strategy is to rely on host identity, and then
work from there. This is particularly convenient on AWS, where EC2 instances get
IAM roles.

This model is challenging to port to new tools like Kubernetes.


<abbr title="Trust On First Use">TOFU</abbr>


# Criteria

Measuring quality based on purely objective criteria is tempting, but many tools
make trade-offs or have interesting design choices that are difficult to compare
objectively. I try not to pick favorites between programming languages.
Deployment concerns are real, and things like having a single binary are nice,
hence projects implement in languages like Go or Rust have an advantage.

Generally speaking, open source is better than closed source. I assume that
major cloud platform providers, like Google's GCP and Amazon's AWS, are already
fundamentally trusted; although less required trust is better. Having had
professional audits is a big plus, but being amenable to informal inspection is
too (hence open source). As a cryptographer, I care about the cryptographic
primitives in use. While choices like randomized-nonce GCM are not intrinsically
serious vulnerabilities, they are questionable enough to warrant additional
scrutiny. Even though the primary consumer for hot secret stores is a computer,
at some point humans are still contributing secrets to it. It'd be nice if we
can securely link those transactions to specific individuals.

<a name="contenders">

# Implementations

Oh boy. There are a few. This is by no means intended to be a complete overview,
although it's pretty comprehensive.

# Encrypted bags

Many implementations follow an encrypted bag model. The secrets are still
managed in source control, although the repository might be separate from the
centralized one. Examples include Chef [data bags][cdb] and
Ansible [Vault][av].

Some implementations provide incremental improvements on this model.

[EJSON][ejson] by Shopify uses strong public-key crypto instead of a shared
symmetric key or password. (At some point in the middle of 2016, they decided to
rewrite it from Ruby to Go. I'm reviewing the current Go version.)

These solutions generally miss the features mentioned earlier. Because the
ciphertexts are statically available to the operator and the key is a shared
password, there is no audit trail for accesses. Fortunately, because the secrets
are managed in source control, these systems automatically keep a historical
record.

These systems are typically tied to a particular deployment model; either
they're a part of a configuration management tool, or the tool is unspecified
(like EJSON). This makes them cumbersome to use for large deployments of
ephemeral, immutable infrastructure.

## [Citadel][citadel]

```
[14:25:21]  <lvh>	coderanger: hey; I'm doing an overview of secret storages -- is citadel something you are recommending people use, and, if so, would you say it is fair to put it in the same category as ansible vaults, chef encrypted bags, chef vault? it seems like even though it's deployed via cookbook it's not particularly tied to using anything else cheffy
[14:25:57]  <coderanger>	Yeah, I would even say it's deployed because it's not really a thing
[14:26:06]  <coderanger>	It's just a usage pattern with a tiny bit of DSL sugar
[14:26:21]  <coderanger>	And yes, still recommended.
[14:26:52]  <coderanger>	I do at some point want to add integration with KMS because someone managed to convince me it wasn't useless security theater but the use case is relative esoteric so I haven't gotten to it yet
[14:27:09]  <coderanger>	(specifically KMS has better IAM permission conditionals than S3 does for some frickin' reason)
[14:29:44]  <coderanger>	Also technically a different category from the three you mentioned because not a pre-encryption scheme :)
[15:05:12]  <mhashemi>	(for bystanders, coderanger gave a great talk about secret storages not long back: https://www.youtube.com/watch?v=unFMJlKGh98 )
[15:06:40]  <coderanger>	Or for a more stable URL (with slides) https://coderanger.net/talks/secrets/
[15:11:33]  <mhashemi>	oh wow, I appreciate an ambitious claim! your personal site structure being more stable than youtube, I hope to live to see the day we find out if it's true. ;)
[15:12:14]  <coderanger>	mhashemi: I've given the talk at a lot of conference and might either switch to a different recording or make my own edit later on
[15:13:07]  <coderanger>	The talk improved a bit over the year, the one I linked is a few months after the one you did
[15:13:26]  <mhashemi>	i appreciate that, too :)
[15:14:24]  <coderanger>	I think the videos from the final place I gave it are up now, I need to watch it and decide if I like it better
[15:26:36]  <mhashemi>	aw, but the questions from this one are so much better https://youtu.be/xZiekP_70EA?t=1836 ;)
[15:30:13] coderanger	still hates listening to his own voice
```

# Cluster operating systems

## Kubernetes

## Docker Swarm

## Mesos

# Configuration storage systems (Consul, Zookeeper...)

# Other systems

## [Vault][vault]

## [PAL][pal]

## [secretary][secretary]

## [biscuit][biscuit]

## [SOPS][sops]

SOPS was at some point implemented in Python, but then got reimplemented in Go.
This review only deals with the current version, since the Python version is
officially deprecated.

Unfortunately [GPG][sops-yk].

[sops-yk]: https://github.com/mozilla/sops/issues/191

## [Torus][torus]

Torus is only partially open source: the client is, but the server is not.

## [Ithos][ithos]

While it is by its own admission not yet ready for prime-time, it gets an
honorable mention for being built on an append-only cryptographically verifiable
log, a la Certificate Transparency. This has interesting security properties.

# Conclusion

Interestingly, several projects were rewritten from languages like Python and
Ruby to Go. While I generally think our industry does that kind of thing too
often, it's hard to fault anyone here. Go is genuinely great at shipping
easy-to-use binaries with strong crypto.



I'd like to thank the following people:

...


[cdb]: https://docs.chef.io/data_bags.html#encrypt-a-data-bag-item
[av]: http://docs.ansible.com/ansible/playbooks_vault.html
[icecap]: https://github.com/lvh/icecap
[ejson]: https://github.com/Shopify/ejson
[citadel]: https://github.com/poise/citadel
[secretary]: https://github.com/meltwater/secretary
[vault]: https://github.com/hashicorp/vault
[pal]: https://www.youtube.com/watch?v=G_JXv059UY0
[biscuit]: https://github.com/dcoker/biscuit
[sops]: https://github.com/mozilla/sops
[torus]: https://www.torus.sh/
[ithos]: https://github.com/cryptosphere/ithos
