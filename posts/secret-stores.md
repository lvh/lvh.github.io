<!--
.. title: Secret stores
.. slug: secret-stores
.. date: 2017-01-18 13:15:16 UTC-08:00
.. tags: private, security, crypto
.. category:
.. link:
.. description:
.. type: text
-->

Applications need secrets. TLS certificates, credentials for your database or
cloud provider: there are plenty of things your application may need access to
that you don't want anyone else to have access to.

Most companies don't have a particularly comprehensive strategy for managing
secrets. They're often committed to version control, kept on one person's
machine, accidentally leaked via environment variables, et cetera. Sometimes
secrets get added to build artifacts like Docker images. There's rarely any kind
of comprehensive story for key rotation or audit logs. Most sets of secrets
don't have the principle of least authority applied to them; applications get
access secrets by default, not by exception, and there's no mechanism in place
for limiting that.

These practices are generally understood to be awful, and there are a lot of
homegrown mechanisms for improving this. For example, the credentials in source
control might be encrypted; moving the trusted actors from "everyone with the
source code" to "the one trusted deployment machine".

This post is not about password managers. Password managers have many similar
design constraints, but are still fundamentally different beasts with completely
different users. Secret stores (as defined in this post) are consumed by
computers. The secrets are often generated by a third party, and are normally
very high entropy (a human wouldn't be able to remember them). By comparison, a
password manager is used by humans, accessed with a relatively low entropy
passphrase, and is often responsible for generating the secrets to begin with.
This post is also not about cold storage, like the physical vault where you keep
your AWS master password.

QQQ small, radioactive, required -- NOT all private information!

This post is intended to be an overview of how we can do better. First, I'll
argue that we can do better at all. If you're already convinced secret stores
are a great idea, you can jump ahead to the [contenders](#contenders).

# Chicken versus egg

At first sight, secret stores might sound like a fool's errand. Clearly, access
to secrets is a sensitive operation that you want to properly authenticate.
Machines authenticate themselves to other machines with high entropy secrets.
So, you still need to give the machine a secret anyway; and it seems like all
you've done is kick the can down the road a little.

There are plenty of useful features a secret store might get you:

* It knows how to encrypt and store secrets securely. Having one specialized
  application have an opinion on how to do that is much better than having a
  hundred ones that do it incidentally. The central one will be audited and
  monitored. The hundreds will invariably mess it up. As the old adage goes:
  defenders have to be right all the time, attackers only have to be right once.

* It tracks who accessed a secret and when. This is critical information for
  remediation and ongoing scope reduction. Knowing who accessed what and when
  probably gives you the context for why; all three tell you how to further
  reduce the authority that application has, or reconstruct a detailed audit
  trail.

* It can generate "minimal" credentials on-demand. Minimal means you get a key
  that only lets you access what you need and for a limited amount of time. For
  example, if you need to access specific AWS resources, you'd only be able to
  access those. On-demand means that they key can be created when you ask for
  it, and isn't shared with anyone else. (This is something dear to my heart;
  while [icecap][icecap] is anything but production software, it's essentially
  this idea turned up to eleven.)

* It can encrypt things on behalf of the requester, such that the requester
  never sees the key. That is good, because it can be one-way. It is also good
  because if a service is compromised, the compromise may be detected and
  remediated (access revoked) before all data is dumped and compromised. Having
  the secret store lets you do e.g. rate limiting and centralized monitoring,
  for example.

* Secret stores can know how secrets are linked; making it easier to do
  revocation, and easier to determine the impact of a breach or misuse incident.

* Once secrets are managed in a centralized place, it becomes feasible to have a
  coherent rotation strategy.

This concept is important to consider, because some schemes do not have these
features, and hence the rationale applies.

# Bootstrapping

This problem of needing some identity or secret to start from is called
*bootstrapping*.

One traditional strategy is to have an administrator deploy secrets to where
they need to go, via a configuration management tool like Chef or Ansible. This
often involves <abbr title="Trust On First Use">TOFU</abbr>. Hosts are
long-living and their identity is either trusted on first use or verified out of
band.

You can also tie host identities to capabilities directly. This is particularly
convenient on AWS, where EC2 instances get IAM roles and hence access to e.g.
KMS and S3.

This model is challenging to port to newer tools like Kubernetes, Mesos, AWS ECS
or Lambda where containers are considered ephemeral and immutable. In these
models, it's more reasonable to think of the immutable artifact being
authenticated (signed) rather than the host it might incidentally run on. That
comes with metadata about what sort of capabilities the application should be
able to access. Just like an application on your phone asks to be able to use
the webcam, the application should ask the host for what it has access to.

QQQQQQQ
[Docker Notary][notary] is an implementation
of [<abbr title="The Update Framework">TUF</abbr>][tuf]. It can be used to audit
provenance of container images.
Credit for this model goes to CloudFlare;
see [Nick Sullivan's B-Sides LV 2016 talk][pal]. It's important to note that
this is not another secret management tool. It's a container identity
bootstrapping tool that bridges the bootstrapping gap.

# Criteria

Measuring quality based on purely objective criteria is tempting, but many tools
make trade-offs or have interesting design choices that are difficult to compare
objectively. I try not to pick favorites between programming languages.
Deployment concerns are real, and things like having a single binary are nice,
hence projects implement in languages like Go or Rust have an advantage.

Generally speaking, open source is better than closed source. I assume that
major cloud platform providers, like Google's GCP and Amazon's AWS, are already
fundamentally trusted; although less required trust is better. Having had
professional audits is a big plus, but being amenable to informal inspection is
too (hence open source). As a cryptographer, I care about the cryptographic
primitives in use. While choices like randomized-nonce GCM are not intrinsically
serious vulnerabilities, they are questionable enough to warrant additional
scrutiny. Even though the primary consumer for hot secret stores is a computer,
at some point humans are still contributing secrets to it. It'd be nice if we
can securely link those transactions to specific individuals.

<a name="contenders">

# Implementations

Oh boy. There are a few. This is by no means intended to be a complete overview,
although it's pretty comprehensive.

# Encrypted bags or pre-encryption

Many implementations follow an encrypted bag model, also known as a
pre-encryption scheme. The secrets are still managed in source control, although
the tool encrypts them first, and the repository might be separate from the one
used to store the source code. Examples include Chef [data bags][cdb] and
Ansible [Vault][av].

Some implementations provide incremental improvements on this model.

Chef Vault layers asymmetric RSA encryption on top of Chef's encrypted data
bags. This effectively builds a key distribution system.

[EJSON][ejson] by Shopify uses strong public-key crypto instead of a shared
symmetric key or password. (At some point in the middle of 2016, they decided to
rewrite it from Ruby to Go. I'm reviewing the current Go version, which
confusingly isn't what the [README tells me to install][ejson-install]).

[SOPS][sops] was at some point implemented in Python, but then got reimplemented
in Go. This review only deals with the current version, since the Python version
is officially deprecated. Unfortunately the new version comes with some
regressions. The old Python version just ran the GPG binary, whereas the new Go
version uses Go's built-in OpenPGP implementation. This is convenient, because
it no longer depends on having GPG installed and you can just use a single
binary. Unfortunately, it also means the former supported hard tokens like a
Yubikey, and [the current version does not][sops-yk]. SOPS does have one awesome
feature: just like GPG internally works by encrypting a session key to different
public keys, SOPS encrypts a session key via GPG and KMS. This means that a
secret in SOPS can be written by GPG keys tightly linked to human identities,
and then consumed by KMS keys tightly linked to machine identities.

All of these solutions generally miss the features mentioned earlier. Because
the ciphertexts are statically available to the operator and the key is a shared
password, there is no audit trail for accesses. Fortunately, because the secrets
are managed in source control, these systems automatically keep a historical
record.

These systems are typically tied to a particular deployment model; either
they're a part of a configuration management tool, or the tool is unspecified
(like EJSON). This makes them cumbersome to use for large deployments of
ephemeral, immutable infrastructure. They generally leave you with a
self-referential problem to solve: you get a secret to access the secrets, but
how do you safely distribute that secret without buying into the deployment
model? (This last criticism doesn't apply to SOPS, since it also supports KMS;
although you're in the same boat if you ever use GPG.) Asymmetric solutions try
to solve this problem, but typically run into problems where they have to
encrypt for many servers: you either re-use keys, or have a large key management
problem on your hands.

# Configuration storage systems (Consul, Zookeeper...)


## [Citadel][citadel]

```
[14:25:21]  <lvh>	coderanger: hey; I'm doing an overview of secret storages -- is citadel something you are recommending people use, and, if so, would you say it is fair to put it in the same category as ansible vaults, chef encrypted bags, chef vault? it seems like even though it's deployed via cookbook it's not particularly tied to using anything else cheffy
[14:25:57]  <coderanger>	Yeah, I would even say it's deployed because it's not really a thing
[14:26:06]  <coderanger>	It's just a usage pattern with a tiny bit of DSL sugar
[14:26:21]  <coderanger>	And yes, still recommended.
[14:26:52]  <coderanger>	I do at some point want to add integration with KMS because someone managed to convince me it wasn't useless security theater but the use case is relative esoteric so I haven't gotten to it yet
[14:27:09]  <coderanger>	(specifically KMS has better IAM permission conditionals than S3 does for some frickin' reason)
[14:29:44]  <coderanger>	Also technically a different category from the three you mentioned because not a pre-encryption scheme :)
[15:05:12]  <mhashemi>	(for bystanders, coderanger gave a great talk about secret storages not long back: https://www.youtube.com/watch?v=unFMJlKGh98 )
[15:06:40]  <coderanger>	Or for a more stable URL (with slides) https://coderanger.net/talks/secrets/
[15:11:33]  <mhashemi>	oh wow, I appreciate an ambitious claim! your personal site structure being more stable than youtube, I hope to live to see the day we find out if it's true. ;)
[15:12:14]  <coderanger>	mhashemi: I've given the talk at a lot of conference and might either switch to a different recording or make my own edit later on
[15:13:07]  <coderanger>	The talk improved a bit over the year, the one I linked is a few months after the one you did
[15:13:26]  <mhashemi>	i appreciate that, too :)
[15:14:24]  <coderanger>	I think the videos from the final place I gave it are up now, I need to watch it and decide if I like it better
[15:26:36]  <mhashemi>	aw, but the questions from this one are so much better https://youtu.be/xZiekP_70EA?t=1836 ;)
```

# Cluster operating systems

## Kubernetes

## Docker Swarm

Docker Swarm's secrets management is new in 1.13 and hence unreleased at time of
writing. Disclaimer: I reviewed some of the cryptography, and the implementation
and guarantees have changed over the course of the project.

## Mesos

# Trusted third party systems

It's clear that some of the features

## [Vault][vault]

Vault does software crypto

## (Building on) hosted platforms

sneaker, credstash both fundamentally rely on KMS; the principal difference is
that sneaker uses S3, and credstash uses DynamoDB. Relying on these tools is
convenient, because it implies not having to run servers. Furthermore, routing
access control through AWS IAM while keeping the key safely locked away in KMS
helps prevent accidental key disclosure.

SOPS deserves an honorable mention here as well, since it's the only tool I
found that does both KMS and OpenPGP.

# Other systems

## [secretary][secretary]

## [biscuit][biscuit]


# Honorable mentions

## [Torus][torus]

Torus is only partially open source: the client is, but the server is not.

## [Ithos][ithos]

While it is by its own admission not yet ready for prime-time, it gets an
honorable mention for being built on an append-only cryptographically verifiable
log, a la Certificate Transparency. This has interesting security properties
from an audit chain perspective, not dissimilar from managing secrets in source
control.

# Conclusion

There are too many secret stores, by far. This is ostensibly nobody's fault.
Many of these tools were developed in-house when no great alternatives were
publicly available. Furthermore, they are too niche for any clear victor to
emerge.

AWS clearly dominates this space. I was unable to find anything that supports
Cloud Key Management Service, GCP's equivalent to KMS. Because of their
similarities, adding support to any of the AWS KMS-powered solutions would not
be particularly complex.

Interestingly, several projects were rewritten from languages like Python and
Ruby to Go. While I think our industry generally does that kind of thing too
often, it's hard to fault anyone here. Go is genuinely great at shipping
easy-to-use binaries with strong cryptography.

In no particular order, I'd like to thank Jeremy Rauch, Noah Kantrowitz, Julien
Vehent, Adrian Utrilla, Nick Sullivan.


[notary]: https://github.com/docker/notary
[tuf]: https://theupdateframework.github.io/
[cdb]: https://docs.chef.io/data_bags.html#encrypt-a-data-bag-item
[av]: http://docs.ansible.com/ansible/playbooks_vault.html
[icecap]: https://github.com/lvh/icecap
[ejson]: https://github.com/Shopify/ejson
[ejson-install]: https://github.com/Shopify/ejson/issues/36
[sneaker]: https://github.com/codahale/sneaker
[credstash]: https://github.com/fugue/credstash
[citadel]: https://github.com/poise/citadel
[secretary]: https://github.com/meltwater/secretary
[vault]: https://github.com/hashicorp/vault
[pal]: https://www.youtube.com/watch?v=G_JXv059UY0
[biscuit]: https://github.com/dcoker/biscuit
[sops]: https://github.com/mozilla/sops
[torus]: https://www.torus.sh/
[ithos]: https://github.com/cryptosphere/ithos
