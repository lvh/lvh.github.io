<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Crypto APIs and JVM byte types | lvh</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">
<link rel="canonical" href="https://www.lvh.io/posts/crypto-apis-and-jvm-byte-types.html">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]--><meta name="author" content="lvh">
<link rel="prev" href="tradeoffs-in-cryptographic-api-design.html" title="Tradeoffs in cryptographic API design" type="text/html">
<link rel="next" href="2016-rmbp-caveats.html" title="2016 rMBP caveats" type="text/html">
<meta property="og:site_name" content="lvh">
<meta property="og:title" content="Crypto APIs and JVM byte types">
<meta property="og:url" content="https://www.lvh.io/posts/crypto-apis-and-jvm-byte-types.html">
<meta property="og:description" content="In a previous post, I talked about crypto API tradeoffs. In this
post, I'll go into a specific API design case in caesium, my
cryptographic library for Clojure, a language that runs on the Java Virtua">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-07-11T14:00:00-07:00">
<meta property="article:tag" content="crypto">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://www.lvh.io/">
                <img src="../pinchy.svg" alt="lvh" id="logo"><span id="blog-title">lvh</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../about.html">About</a>
                </li>
<li>
<a href="../archive.html">Archive</a>
                </li>
<li>
<a href="../categories/index.html">Tags</a>
                </li>
<li>
<a href="../talks.html">Talks</a>
                </li>
<li>
<a href="../rss.xml">RSS feed</a>

                
            </li>
</ul>
<!-- Custom search --><form method="get" id="search" action="//duckduckgo.com/" class="navbar-form pull-right">
<input type="hidden" name="sites" value="https://www.lvh.io/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="display: none;">
</form>
<!-- End of custom search -->


            <ul class="nav navbar-nav navbar-right">
<li>
    <a href="crypto-apis-and-jvm-byte-types.md" id="sourcelink">Source</a>
    </li>

                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Crypto APIs and JVM byte types</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                    lvh
            </span></p>
            <p class="dateline"><a href="#" rel="bookmark"><time class="published dt-published" datetime="2016-07-11T14:00:00-07:00" itemprop="datePublished" title="2016-07-11 14:00">2016-07-11 14:00</time></a></p>
            
        <p class="sourceline"><a href="crypto-apis-and-jvm-byte-types.md" id="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>In a previous post, I talked about <a href="tradeoffs-in-cryptographic-api-design.html">crypto API tradeoffs</a>. In this
post, I'll go into a specific API design case in <a href="https://github.com/lvh/caesium"><code>caesium</code></a>, my
cryptographic library for Clojure, a language that runs on the Java Virtual
Machine.</p>
<h3>JVM byte types</h3>
<p>The JVM has several standard byte types. For one-shot cryptographic APIs, the
two most relevant ones are byte arrays (also known as <code>byte[]</code>) and
<code>java.nio.ByteBuffer</code>.  Unfortunately, they have different pros and cons, so
there is no unambiguously superior choice.</p>
<p><code>ByteBuffer</code> can produce slices of byte arrays and other byte buffers with
zero-copy semantics. This makes a useful tool when want to place an encrypted
message in a pre-allocated binary format. One example of this is my
<a href="https://github.com/lvh/caesium/blob/master/src/caesium/magicnonce/secretbox.clj">experimental NMR suite</a>. Another use case is generating more than
one key out of a single call to a key derivation function. The call produces
one (long) output, and <code>ByteBuffer</code> lets you slice it into different keys.</p>
<p>Byte arrays are easily serializable, but <code>ByteBuffer</code> is not. Even if you
teach your serialization library about <code>ByteBuffer</code>, this usually results in
extra copying during serialization.</p>
<p>Byte arrays are constant length, and that length is stored with the array, so
it's cheap to access. Figuring out how much to read from a <code>ByteBuffer</code>
requires a (trivial) amount of math by calling <code>remaining</code>. This is because
the <code>ByteBuffer</code> is a view, and it can be looking at a different part of the
underlying memory at different times. For a byte array, this is all fixed: a
byte array's starting and stopping points remain constant. Computing the
remaining length of a <code>ByteBuffer</code> may not always be constant time, although
it probably is. Even if it isn't, it's probably not in a way that is relevant
to the security of the scheme (in <code>caesium</code>, only cryptographic hashes,
detached signatures and detached MACs don't publicly specify the message
length).</p>
<p><code>ByteBuffer</code> has a public API for allocating <em>direct</em> buffers. This means they
are not managed by the JVM. Therefore they won't be copied around by the
garbage collector, and memory pinning is free. "Memory pinning" means that you
notify the JVM that some external C code is using this object, so it should
not be moved around or garbage collected until that code is done using that
buffer. You can't pass "regular" (non-direct) buffers to C code. When you do
that, the buffer is first copied under the hood. Directly allocated buffers
let you securely manage the entire lifecycle of the buffer. For example, they
can be securely zeroed out after use. Directly allocated <code>ByteBuffer</code>
instances might have underlying arrays; this is explicitly unspecified.
Therefore, going back to an array <em>might</em> be zero-copy. In my experiments,
these byte buffers never have underlying arrays, so copying is always
required. I have not yet done further research to determine if this generally
the case. In addition to <code>ByteBuffer</code>, the<code>sun.misc.Unsafe</code> class does have
options for allocating memory directly, but it's pretty clear that use of that
class is strongly discouraged. Outside of the JDK, the <code>Pointer</code> API in
<code>jnr-ffi</code> works identically to <code>ByteBuffer</code>.</p>
<h3>Design decisions</h3>
<p>As a brief recap from my previous post, it's important that we design an API
that makes common things easy and hard things possible while remaining secure
and performant. For the cryptographic APIs in <code>caesium</code>, there are a number of
variables to consider:</p>
<ul>
<li>Are the return types and arguments <code>ByteBuffer</code> instances, byte arrays
   (<code>[B</code>), <code>Pointer</code> instances, or something else?</li>
<li>Is the return type fixed per exposed function, or is the return
   type based on the input types, like Clojure's <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/empty"><code>empty</code></a>?</li>
<li>Are the APIs "C style" (which passes in the output buffer as an argument)
   or "functional style" (which allocates the output buffer for you)?</li>
<li>Does the implementation convert to the appropriate type (which might
   involve copying), does it use reflection to find the appropriate type, does
   it explicitly dispatch on argument types, or does it assume you give
   it some specific types?</li>
</ul>
<p>Many of these choices are orthogonal, meaning we can choose them
independently. With dozens of exposed functions, half a dozen or so arguments
per function with 2-4 argument types each, two function styles, four argument
conversion styles, and two ways of picking the return type, this easily turns
into a combinatorial explosion of many thousands of exposed functions.</p>
<p>All of these choices pose trade-offs. We've already discussed the differences
between the different byte types, so I won't repeat them here. Having the
function manage the output buffer for you is the most convenient option, but
it also precludes using direct byte buffers effectively. Type conversion is
most convenient, but type dispatch is faster, and statically resolvable
dispatching to the right implementation is faster still. The correct return
value depends on context. Trying to divine what the user really wanted is
tricky, and, as we discussed before, the differences between those types are
significant.</p>
<p>The functions exposed in caesium live on the inside of a bigger system, in the
same sense that IO libraries like <a href="https://twistedmatrix.com/">Twisted</a> and <a href="https://github.com/ztellman/manifold">manifold</a>
live on the edges. Something gives you some bytes, you perform some
cryptographic operations on them, and then the resulting bytes go somewhere
else. This is important, because it reduces the number of contexts in which
people end up with particular types.</p>
<h3>Implementing the API</h3>
<p>One easy decision is that the underlying binding should support every
permutation, regardless of what the API exposes. This would most likely
involve annoying code generation in a regular Java/jnr-ffi project, but
caesium is written in Clojure. The information on how to bind libsodium is a
Clojure data structure that gets compiled into an interface, which is what
jnr-ffi consumes. This makes it easy to expose every permutation, since it's
just some code that operates on a value. You can see this at work in the
<a href="https://github.com/lvh/caesium/blob/master/src/caesium/binding.clj#L13"><code>caesium.binding</code> namespace</a>. As a consequence, an expert
implementer (who knows exactly which underlying function they want to call
with no "smart" APIs or performance overhead) can always just drop down to the
binding layer.</p>
<p>Another easy call is that all APIs should raise exceptions, instead of
returning success codes. Success codes make sense for a C API, because there's
no reasonable exception mechanism available. However, problems like failed
decryption should definitely just raise exceptions.</p>
<p>It gets tricky when we compare APIs that take an output buffer versus APIs
that build the output buffer for you. The latter are clearly the easiest to
use, but the former are necessary for explicit buffer life cycle
management. You can also easily build the managed version from the unmanaged
version, but you can't do the converse. As a consequence, we should expose
both.</p>
<p>Having to expose both has the downside that we haven't put a dent in that
combinatorial explosion of APIs yet. Let's consider the cases in which someone
might have a byte buffer:</p>
<ul>
<li>They're using them as a slice of memory, where the underlying memory could
   be another byte buffer (direct or indirect) or a byte array -- usually a
   byte array wrapping a byte buffer.</li>
<li>They're managing their own (presumably direct) output buffers.</li>
</ul>
<p>In the former case, the byte buffers primarily act as inputs. In the latter,
they exclusively act as outputs. Because both byte buffers and byte arrays can
act as inputs, any API should be flexible in what it accepts. However, this
asymmetry in how the types are used, and how they can be converted, has
consequences for APIs where the caller manages the output buffer versus APIs
that manage it for you.</p>
<p>When the API that manages the output buffer for you, the most reasonable
return type is a byte array. There is no difference between byte arrays
created by the API and those created by the caller, and there's no reasonable
way to reuse them. If you do really need a byte buffer for some reason,
wrapping that output array is simple and cheap. Conversely, APIs where the
caller manages the output buffer should use output byte buffers. Callers who
are managing their own byte buffer need to call an API that supports that, and
there's nothing to be gained from managing your own byte arrays (only direct
byte buffers). This is fine for internal use within <code>caesium</code> — the byte array
producing API can just wrap it in a byte buffer view.</p>
<p>This means we've reduced the surface significantly: APIs with caller-managed
buffers output to <code>ByteBuffer</code>, and APIs that manage it themselves return byte
arrays. This takes care of the output types, but not the input types.</p>
<p>Keys, salts, nonces, messages et cetera will usually be byte arrays, since
they're typically just read directly from a file or made on the spot. However
rare, there can be good reasons for having any of these as byte buffers. For
example, a key might have been generated from a different key using a key
derivation function; a nonce might be synthetically generated (as with
deterministic or nonce-misuse resistant schemes); either might be randomly
generated but just into a pre-existing buffer.</p>
<p>The easiest way for this to work by default is reflection. That mostly works,
until it doesn't. Firstly, reflecting can be brittle. For example, if all of
your byte sequence types are known but a buffer length isn't, Clojure's
reflection will fail to find the appropriate method, even if it is
unambiguous. Secondly, unannotated Clojure fns always take boxed objects, not
primitives, which is what we want for calling into C. Annotating is imperfect,
too, because it moves the onus of producing a primitive to the caller. These
aren't really criticisms of Clojure. At this point we're well into weird edge
case territory which this system wasn't designed for.</p>
<p>We can't do static dispatch for the public API, because we've established that
we should be flexible in our input types. We can work around the unknown type
problems with reflection using explicitly annotated call sites. That means
we're dispatching on types, which comes with its own set of issues. In the
next blog post, I'll go into more detail on how that works, with a bunch of
benchmarks. Stay tuned!</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../categories/crypto.html" rel="tag">crypto</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="tradeoffs-in-cryptographic-api-design.html" rel="prev" title="Tradeoffs in cryptographic API design">Previous post</a>
            </li>
            <li class="next">
                <a href="2016-rmbp-caveats.html" rel="next" title="2016 rMBP caveats">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2017         <a href="mailto:_@lvh.io">lvh</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-36779422-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
