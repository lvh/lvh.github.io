<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Creating smaller Docker images by separating build and runtime environments">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Smaller Clojure Docker builds with multi-stage builds | lvh</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#383234">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://www.lvh.io/posts/smaller-clojure-docker-builds-with-multi-stage-builds/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="lvh">
<link rel="prev" href="../2016-rmbp-caveats/" title="2016 rMBP caveats" type="text/html">
<meta property="og:site_name" content="lvh">
<meta property="og:title" content="Smaller Clojure Docker builds with multi-stage builds">
<meta property="og:url" content="https://www.lvh.io/posts/smaller-clojure-docker-builds-with-multi-stage-builds/">
<meta property="og:description" content="Creating smaller Docker images by separating build and runtime environments">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-06-16T10:12:46-07:00">
<meta property="article:tag" content="clojure">
<meta property="article:tag" content="docker">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="https://www.lvh.io/">
            <img src="../../pinchy.svg" alt="lvh" id="logo" class="d-inline-block align-top"><span id="blog-title">lvh</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../about.html" class="nav-link">About</a>
                </li>
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../talks.html" class="nav-link">Talks</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<!-- Custom search --><form method="get" id="search" action="//duckduckgo.com/" class="navbar-form pull-right">
<input type="hidden" name="sites" value="https://www.lvh.io/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="display: none;">
</form>
<!-- End of custom search -->


            <ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Smaller Clojure Docker builds with multi-stage builds</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    lvh
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2017-06-16T10:12:46-07:00" itemprop="datePublished" title="2017-06-16 10:12">2017-06-16 10:12</time></a>
            </p>
            
        <p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>A common pattern in Docker is to use a separate build environment from the
runtime environment. Many platforms have different requirements when you're
generating a runnable artifact than when you're running it.</p>
<p>In languages like Go, Rust or C, where the most common implementations produce
native binaries, the resulting artifact may require nothing from the environment
at all, or perhaps as little as a C standard library. Even in languages like
Python that don't typically have a build step, you might indirectly use code
that still requires compilation. Common examples include OpenSSL with
pyca/cryptography or NETLIB and other numerical libraries with numpy/scipy.</p>
<p>In Clojure, you can easily build "uberjars" with both lein and boot. These are
jars (the standard JVM deployable artifact) that come with all dependencies
prepackaged, requiring nothing beyond what's in the Java standard library
(rt.jar). While this still requires a JRE to run, that is still much smaller
than the full development environment.</p>
<p>There are a few advantages to separating environments. It all boils down to them
not having anything in them they don't need. That has clear performance
advantages, although Docker has historically mitigated this problem with layered
pulls. It can have security benefits as well: you can't have bugs in software
you don't ship. Even software that isn't directly used in the build process can
be affected: some build environments will contain plenty of software that is
never used that would normally carry over into your production environments.</p>
<p>Historically, most users of Docker haven't bothered. Even if there are
advantages, they aren't worth the hassle of having separate Docker environments
and ferrying data between them. While different ways of effectively sharing data
between containers have been available for years, people who wanted a shared
build step have mostly had to write their own tooling. For example,
my <a href="https://github.com/lvh/icecap/blob/master/utils/build-libsodium-package.sh">icecap</a> project has a batch file with an embedded Dockerfile that builds
libsodium debs.</p>
<p>The upcoming release of Docker will add support for a new feature called
multi-stage builds, where this pattern is much simpler. Dockerfiles themselves
know about your precursor environments now, and future containers have full
access to previous containers for copying build artifacts around. This
requires Docker 17.05 or newer.</p>
<p>Here's an example Dockerfile that builds an uberjar from a standard lein-based
app, and puts it in a new JRE image:</p>
<pre class="code literal-block"><span></span><span class="k">FROM</span> <span class="n">clojure</span> <span class="k">AS</span> <span class="n">build</span><span class="o">-</span><span class="n">env</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">myapp</span>
<span class="k">COPY</span> <span class="n">project</span><span class="p">.</span><span class="n">clj</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">myapp</span><span class="o">/</span>
<span class="n">RUN</span> <span class="n">lein</span> <span class="n">deps</span>
<span class="k">COPY</span> <span class="p">.</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">myapp</span>
<span class="n">RUN</span> <span class="n">mv</span> <span class="ss">"$(lein uberjar | sed -n 's/^Created \(.*standalone\.jar\)/\1/p')"</span> <span class="n">myapp</span><span class="o">-</span><span class="n">standalone</span><span class="p">.</span><span class="n">jar</span>

<span class="k">FROM</span> <span class="n">openjdk</span><span class="p">:</span><span class="mi">8</span><span class="o">-</span><span class="n">jre</span><span class="o">-</span><span class="n">alpine</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">myapp</span>
<span class="k">COPY</span> <span class="c1">--from=build-env /usr/src/myapp/myapp-standalone.jar /myapp/myapp.jar</span>
<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="ss">"java"</span><span class="p">,</span> <span class="ss">"-jar"</span><span class="p">,</span> <span class="ss">"/myapp/myapp.jar"</span><span class="p">]</span>
</pre>


<p>This captures the uberjar name from the <code>lein uberjar</code> output. If your uberjar
name doesn't end in <code>.standalone.jar</code>, that won't work. You can change the name
of the uberjar with the <code>:uberjar-name</code> setting in <code>project.clj</code>. If you set it
to <code>myapp-standalone.jar</code>, you don't need the gnarly <code>sed</code> expression anymore at
all, and can just call <code>lein uberjar</code>. (Thanks to Łukasz Korecki for the
suggestion!)</p>
<p>The full clojure base image is a whopping 629MB (according to <code>docker images</code>),
whereas <code>openjdk:8-jre-alpine</code> clocks in at 81.4MB. That's a little bit of an
unfair comparison: <code>clojure</code> also has an alpine-based image. However, this still
illustrates the savings compared to the most commonly used Docker image.</p>
<p>There are still good reasons for not using multi-stage builds. In the icecap
example above, the entire point is to use Docker as a build system to produce
a deb artifact <em>outside of Docker</em>. However, that's a pretty exotic use case:
for most people this will hopefully make smaller Docker images an easy
reality.</p>
<p><em>Edited:</em> The original blog post said that the Docker version to support this
feature was in beta at time of writing. That was/is correct, but it's since
been released, so I updated the post.</p>
<p><em>Edited:</em>* Łukasz Korecki pointed out that <code>project.clj</code> has an <code>:uberjar-name</code>
parameter which can be used to avoid the gnarly <code>sed</code> expression. Thanks Łukasz!</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/clojure/" rel="tag">clojure</a></li>
            <li><a class="tag p-category" href="../../categories/docker/" rel="tag">docker</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../2016-rmbp-caveats/" rel="prev" title="2016 rMBP caveats">Previous post</a>
            </li>
        </ul></nav></aside></article><!--End of body content--><footer id="footer">
            Contents © 2019         <a href="mailto:_@lvh.io">lvh</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-36779422-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
